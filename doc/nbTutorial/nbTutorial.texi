\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nbTutorial.info
@include version-nbTutorial.texi
@settitle NodeBrain Tutorial
@dircategory NodeBrain
@direntry
* nbTutorial: (nbTutorial).       NodeBrain Tutorial
@end direntry
@set UPDATED-YEAR 2014
@c %**end of header

@finalout
@paragraphindent none
@setchapternewpage odd

@copying
NodeBrain Tutorial@*
@value{UPDATED-MONTH}@*
NodeBrain Open Source Project

@sp 2
@b{Release @value{VERSION}}

Author: Ed Trettevik

Copyright @copyright{} @value{UPDATED-YEAR} Ed Trettevik <eat@@nodebrain.org>

@sp 1
Permission is granted to copy, distribute and/or modify this document under the terms of either the MIT License (Expat) or the NodeBrain License.
@sp 1
@include licenses.texi
@end copying

@iftex
@titlepage
@c @image{./image001,32pt,32pt,,gif}

@titlefont{NodeBrain Tutorial}
@sp 1
@tex
\vskip4pt \hrule height 3pt width \hsize
@end tex
@sp 3
@b{Release @value{VERSION}}
@page
@vskip 0pt plus 1filll
@insertcopying

@c History Preface and Document Conventions 
@page
@b{History}

@multitable {-------------} {--------------------------------------------------------------------------------------------------------}
@item 2005-10-12 @tab
Title: @i{NodeBrain  Tutorial}@*  
Author: Ed  Trettevik <eat@@nodebrain.org>@*
Publisher: NodeBrain Open Source Project

@item @tab
Version 0.6.3 (not released)  
@itemize @bullet
@item Operating mode tutorial   
@end itemize

@item 2006-04-04 @tab   
Release 0.6.4
@itemize @bullet
@item Included interface examples of release 0.6.4 enhancement.
@item Included cell formula and ignorance tutorials.
@end itemize

@item 2007-01-03 @tab   
Version 0.6.6 (not released)  
@itemize @bullet
@item Minor corrections  
@end itemize

@item 2007-07-03 @tab   
Version 0.6.8 (not released)  
@itemize @bullet
@item Terminology change: "node" replaces "expert"
@end itemize

@item 2008-08-20 @tab   
Version 0.7.1 (not released)
@itemize @bullet
@item Updated with 0.7 syntax changes (see @i{NodeBrain Language Reference})
@item Included translator, servant, pipe, audit, peer, and webster node tutorials
@end itemize

@item 2009-02-05 @tab   
Release 0.7.4   
@itemize @bullet
@item Included tree, cache, syslog, and snmptrap node tutorials
@end itemize

@item 2009-03-04 @tab
Release 0.7.5
@itemize @bullet
@item Refined for PDF
@item Several minor corrections
@end itemize

@item 2010-12-31 @tab
Release 0.8.3
@itemize @bullet
@item Moved the Webster tutorial to the Webster NodeBrain Module manual.
@end itemize

@item 2012-06-03 @tab
Version 0.8.10 (Not released)
@itemize @bullet
@item Corrections by Cheryl Hauser
@end itemize

@item 2012-12-30 @tab
Release 0.8.13
@itemize @bullet
@item Included additional examples of rule actions and shell commands.
@end itemize

@end multitable

@page
@b{Preface}

@sp 1
This tutorial is intended for readers seeking an introduction to NodeBrain through a series of simple examples.  Other documents are available for readers looking for a more complete reference to the rule language, modules, or API (application programmatic interface).

The intent of the examples in this tutorial is to illustrate individual concepts, not to provide complete working applications or show all related options.
We avoid formal syntax descriptions, thinking you are here because you want to figure it out from examples.  

Files referenced in this tutorial are included in the tutorial directory of the NodeBrain distribution.  

See www.nodebrain.org for more information and the latest update to this document.

@include ../documents.texi
@include ../conventions.texi

@end titlepage

@end iftex

@c ----------------------------------------------------------
@c Not printed document

@ifnottex
@node Top, Invoking NodeBrain, (nodebrain), (nodebrain)
@top NodeBrain Tutorial 

This tutorial is for the NodeBrain rule engine, an open source agent
for state and event monitoring applications.
The tutorial is intended for programmers new to NodeBrain rule development.
After completing this tutorial, refer to the @i{NodeBrain Language Reference} and
node module manuals for additional information.

Release @value{VERSION}, @value{UPDATED-MONTH}

Copyright @copyright{} @value{UPDATED-YEAR} Ed Trettevik <eat@@nodebrain.org>

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of either the MIT License (Expat) or NodeBrain License.
See the @i{Licenses} section at the end of this document for details.
@end quotation

@ifnotplaintext
@b{Rule Engine Tutorials}
@end ifnotplaintext
@menu
* Invoking NodeBrain:: Interactive, batch, servant, and agent
* Cell Formulas:: Specifying rule conditions
* Ignorance:: Dealing with the unknown
* Rules:: State and event  monitoring
* Syntax Surprises:: You might have expected something different
@end menu

@ifnotplaintext
@b{Node Module Tutorials}
@end ifnotplaintext
@menu
* Tree:: A memory lookup structure
* Cache:: Monitoring repetition and variation
* Baseline:: Detecting statistical anomalies
* Servant:: Integrating with your scripts and programs
* Translator:: Converting text to NodeBrain commands
* Audit:: Log monitoring
* Syslog:: Remote syslog monitoring
* Snmptrap:: Monitoring SNMP traps
* Pipe:: Simple command stream
* Peer:: NodeBrain to NodeBrain
* Webster:: Minimal web interface
@end menu

@ifnotplaintext
@b{References}
@end ifnotplaintext
@menu
* Licenses::
* Index::
@end menu
@end ifnottex

@c Set page footings
@oddfooting @thistitle @| @| @thispage
@evenfooting @thispage @| @| @thistitle

@c Contents
@oddheading @| @| 
@evenheading @| @|
@contents

@c Set page headings for document
@oddheading @thischapter @| @| @value{UPDATED-MONTH}
@evenheading @value{UPDATED-MONTH} @| @| @thischapter


@node Invoking NodeBrain   
@chapter Invoking NodeBrain
@cindex invoking NodeBrain

@sp 1
This tutorial illustrates how to invoke NodeBrain and introduces you to modes of operation that enable NodeBrain to adapt in minor ways to the requirements of different components within a monitoring application.  Some basic concepts about the language syntax and semantics are introduced along the way.  

@menu
* Interactive Mode::
* Batch Mode::
* Servant Mode::
* Agent Mode::
@end menu

@node Interactive Mode
@section Interactive Mode

The easiest way to get started with NodeBrain is to invoke it interactively, type some commands, and watch it respond.  This tutorial walks you through some simple interactive sessions.

@menu
* Starting and Ending an Interactive Session::
* Assertions::
* On Rules::
* Shell Commands::
* Consulting Servant Scripts::
* Rule Actions::
* Action Servant Scripts::
* Rule Files::
@end menu


@node Starting and Ending an Interactive Session
@subsection Starting and Ending an Interactive Session

If you execute NodeBrain with no arguments, it starts in interactive mode and presents a prompt.  At a Unix or Linux shell command prompt, you start NodeBrain by typing @code{nb}.  It looks like this.

@cartouche
@smallexample
$ @b{nb}

N o d e B r a i n   0.9.02 (Columbo) 2014-02-15

Compiled Jun 12 2014 19:20:12 x86_64-unknown-linux-gnu

Copyright (C) 2014 Ed Trettevik <eat@@nodebrain.org>
MIT or NodeBrain License
----------------------------------------------------------------

nb 

Date       Time     Message
---------- -------- --------------------------------------------
2014-06-12 19:56:02 NB000I NodeBrain nb[10656] myuser@@myhost
2014-06-12 19:56:02 NB000I Reading from standard input.
---------- --------

> 
@end smallexample
@end cartouche

Since the information NodeBrain displays when starting up is not important to the topics covered in this tutorial, I don't include it in the examples.  The example above is shown as this.

@cartouche
@smallexample
$ @b{nb}
> 
@end smallexample
@end cartouche

At a Windows command prompt, it looks like this.

@cartouche
@smallexample
C:> @b{nb}
> 
@end smallexample
@end cartouche

For the examples in this tutorial, use a Unix-style shell command prompt.

To end an interactive session, just tell NodeBrain you want to quit.

@cartouche
@smallexample
$ nb
> @b{quit}
$
@end smallexample
@end cartouche

You may also use Cntl-D or Cntl-C to end an interactive session.

@node Assertions
@subsection Assertions

@quotation
@i{The partisan, when he is engaged in a dispute, cares nothing about the rights of the question, but is anxious only to convince his hearers of his own assertions.} ---Plato (427 BC--347 BC), @i{Dialogues, Phaedo}
@end quotation

It is quite easy to convince NodeBrain of your own assertions.  It looks like this.

@cartouche
@smallexample
$ nb
> @b{assert a=1,b=2,mood="happy";}
@end smallexample
@end cartouche

To verify that NodeBrain is willing to accept your assertions, ask it to show you what it now believes about a, b, and mood:

@cartouche
@smallexample
> @b{show a}
a = 1
> @b{show b}
b = 2
> @b{show mood}
mood = "happy"
> quit
@end smallexample
@end cartouche

@node On Rules
@subsection Rules

@quotation
@i{Hell, there are no rules here---we're trying to accomplish something.}
---Thomas A. Edison (1847--1931)
@end quotation

If you are trying to accomplish something with NodeBrain and there are no rules, you are using the wrong tool.  NodeBrain is a rule engine, not a general purpose shell or scripting language.  There are many good shells and scripting languages to choose from, and much to be accomplished without rules---at least not the kind of rules we are talking about here.  In a more general sense, no computing exists without rules, but the kind of rules you find in NodeBrain and similar tools are not appropriate for most computing problems.  However, they can be quite handy when applied to the right problems.

Let's start with a rule that doesn't accomplish anything.

@cartouche
@smallexample
$ nb
> @b{define myFirstRule on(a=1 and b=2);}
> assert a=1;
> assert c=3;
> assert b=2;
2014-06-12 20:19:05 NB000I Rule myFirstRule fired
> assert a=0;
> assert c=1;
> assert a=1;
2014-06-12 20:19:21 NB000I Rule myFirstRule fired
> quit
$
@end smallexample
@end cartouche

What just happened there?  Well, you defined a rule named @code{myFirstRule} and specified a condition @code{(a=1 and b=2)} under which you want it to fire.  Each time this condition transitioned to a "true" state, the rule fired.

Let's modify this example to make it accomplish something---perhaps an assertion.  

@cartouche
@smallexample
$ nb
> @b{define mySecondRule on(a=1 and b=2) mood="happy";}
> assert mood="sad";
> show mood
mood = "sad"
> assert a=1,b=2,c=3;
2014-06-12 20:20:48 NB000I Rule mySecondRule fired(mood="happy")
> show mood
mood = "happy"
> quit
$
@end smallexample
@end cartouche

The assertion that a=1, b=2, and c=3 changed the mood from "sad" to "happy."  Who said you can't accomplish something by following rules?

@node Shell Commands
@subsection Shell Commands

@quotation
@i{She did not talk to people as if they were strange hard shells she had to crack open to get inside. She talked as if she were already in the shell. In their very shell.}   ---Marita Bonner
@end quotation

From NodeBrain you can get into the host systems command shell by using a command prefix of dash (@code{-}).

@cartouche
@smallexample
$ nb
> @b{-date}
[17445] Started: -date
[17445| Thu Jun 12 20:27:00 EDT 2014
[17445] Exit(0)
> @b{-ls -al kim.nb}
[17478] Started: -ls -al kim.nb
[17478| -rw-r--r-- 1 myuser users Jun 12 21:11 kim.nb
[17478] Exit(0)
> quit
$
@end smallexample
@end cartouche

When you talk as if you are in someone else's shell, you need to speak their language.  Here's an example on Windows.

@cartouche
@smallexample
C:> nb
> @b{-dir}
[1060] Started: -dir
[1060|  Volume in drive C has no label.
[1060|  Volume Serial Number is 0C62-77CF
[1060|
[1060|  Directory of C:\home\nodebrain\nb-0.6.4-source.msdsw\Release
[1060|
[1060| 03/28/2006  05:23 PM    <DIR>          .
[1060| 03/28/2006  05:23 PM    <DIR>          ..
[1060| 03/28/2006  04:26 PM           303,104 nb.exe
[1060| 03/28/2006  04:26 PM            10,163 nb.exp
[1060| 03/28/2006  04:26 PM            17,728 nb.lib
[1060|                3 File(s)      2,942,497 bytes
[1060|                2 Dir(s)  11,946,586,112 bytes free
[1060] Exit(0)
> quit
$
@end smallexample
@end cartouche

You can run a shell command in blocking mode using the @code{-} symbol, or non-blocking mode using the @code{=} symbol.
The following example illustrates the different using @code{=echo} and @code{-cat} commands.
The interpreter waits for a blocking shell command to finish before prompting for the next interactive command.
It does not wait for a non-blocking shell command to finish.

@cartouche
@smallexample
> =echo `date` ": it happened" >> happening.log
2014-06-12 20:27:00 NB000I [12756] Started: =echo `date` ": it happened" >> happening.log
> -cat happening.log
2014-06-12 20:27:08 NB000I [12756] Exit(0)
[12759] Started: -cat happening.log
[12759| Thu Jun 12 20:27:00 EDT 2014 : it happened
[12759] Exit(0)
> =echo `date` ": it happened" >> happening.log
2014-06-12 20:27:31 NB000I [12760] Started: =echo `date` ": it happened" >> happening.log
> 
2014-06-12 20:27:32 NB000I [12760] Exit(0)
> -cat happening.log
[12763] Started: -cat happening.log
[12763| Thu Jun 12 20:27:00 EDT 2014 : it happened
[12763| Thu Jun 12 20:27:31 EDT 2014 : it happened
[12763] Exit(0)
@end smallexample
@end cartouche

Try the example above for yourself.  After the second @code{=echo} command, press enter without a command.
In interactive mode, the command prompt blocks the interpreter.
This explains why the interpreter didn't report the completion of the first @code{=echo} command until
after the subsequent @code{-cat} command.

By default the output of a non-blocking shell command is not displayed by the interpreter.
You can direct the interpreter to display the output of a non-blocking shell command using @code{=|}.
Try the following example, pressing the enter key once without a command after the @code{=|echo} command.

@cartouche
@smallexample
> =|echo abc;echo def;echo xyz
2014-06-12 20:34:49 NB000I [12769] Started: =|echo abc;echo def;echo xyz
> 
2014-06-12 20:34:50 NB000I [12769| abc
2014-06-12 20:34:50 NB000I [12769| def
2014-06-12 20:34:50 NB000I [12769| xyz
@end smallexample
@end cartouche

When you direct NodeBrain to execute a shell command to perform a task, the child process is called a @i{servant}.

@node Consulting Servant Scripts
@subsection Consulting Servant Scripts

@quotation
@i{CONSULT, v.i. To seek another's disapproval of a course already decided on.}  --- Ambrose Bierce (1842--1914), @i{The Devil's Dictionary}
@end quotation

NodeBrain is willing to accept the advice of others---even servants.  To illustrate, let's first write a simple Perl script named @code{processCount.pl} that checks to see how many processes are running on a Unix system.

@cartouche
@smallexample
#!/usr/bin/perl
chomp($processes=`ps -e|wc -l`);
print("assert processes=$processes;\n");
@end smallexample
@end cartouche

Now let's execute it in the Unix command shell.

@cartouche
@smallexample
$ ./processCount.pl
assert processes=40;
@end smallexample
@end cartouche

Now you can consult this script from NodeBrain by using a prefix of @code{-:} instead of just @code{-}.  This tells NodeBrain to accept the output of the shell command as input to the NodeBrain interpreter.

@cartouche
@smallexample
$ nb
> @b{-:./processCount.pl}
[17537] Started: -:./processCount.pl
[17537: assert processes=40;
[17537] Exit(0) 
> show processes
processes = 40
> quit
$
@end smallexample
@end cartouche

To consult a servant using non-blocking mode, use @code{=:}.
This is illustrated by the following example.
Since we are in interactive mode, the interpreter blocks waiting for
command input, and you must enter empty commands twice to watch the
shell command finish.

@cartouche
@smallexample
$ nb
> assert !x;
> show x
x = !
> @b{=:echo "assert x=1";echo "show x";echo "assert x=2"}
2014-06-12 20:47:01 NB000I [23949] Started: =:echo "assert x=1";echo "show x";echo "assert x=2"
> 
2014-06-12 20:47:02 NB000I [23949: assert x=1
2014-06-12 20:47:02 NB000I [23949: show x
x = 1
2014-06-12 20:47:02 NB000I [23949: assert x=2
> show x
2014-06-12 20:47:08 NB000I [23949] Exit(0)
x = 2
@end smallexample
@end cartouche


@node Rule Actions
@subsection Rule Actions

@quotation
@i{You ask me why I do not write something...I think one's feelings waste themselves in words, they ought all to be distilled into actions and into actions which bring results.}
---Florence Nightingale (1820--1910), in Cecil Woodham-Smith, @i{Florence Nightingale,} 1951
@end quotation

Any NodeBrain command can be used as a rule action by following the rule condition with a colon (@code{:}) and the action command.

@cartouche
@smallexample
$ nb
> define cmdRule on(a and b)@b{: show x;}
> assert x=3;
> assert a,b;
2014-06-12 21:53:21 NB000I Rule cmdRule fired
: show x;
x = 3
> quit
$
@end smallexample
@end cartouche

An assertion may be included as part of a rule action following the condition and preceeding the action command.

@cartouche
@smallexample
$ nb
> define cmdRule on(a and b) x=3:show x;
> assert a,b;
2014-06-12 21:56:27 NB000I Rule cmdRule fired (x=3)
: show x;
x = 3
> quit
$
@end smallexample
@end cartouche

A rule action may also have an assertion without a command, as illustrated below.

@cartouche
@smallexample
$ nb
> define cmdRule on(a and b) x=3;
> assert a,b;
2014-06-12 21:58:20 NB000I Rule cmdRule fired (x=3)
> show x
x = 3
> quit
$
@end smallexample
@end cartouche


@node Action Servant Scripts
@subsection Action Servant Scripts

When the action you want to take in response to a condition is not a trivial command, you can often turn it into one by writing a script in your favorite scripting language.  I illustrate this in an odd way by writing a trivial Perl script and ask you to imagine that it isn't trivial. Call this script @code{alarmMe.pl}.

@cartouche
@smallexample
alarmMe.pl
#!/usr/bin/perl
$id=shift();
$msg=shift();
$me=getpwuid($<);
system("mailx -s \"$id: $msg\" $me < note$id.txt");
@end smallexample
@end cartouche

Here's a session that uses a rule that invokes the @code{alarmMe.pl} script as a servant.

@cartouche
@smallexample
$ nb
> define alarmRule on(a):-./alarmMe.pl 1 "Things aren't looking good"
> assert a;
2014-06-12 22:05:14 NB000I Rule alarmRule fired
: -./alarmMe.pl 1 "Things aren't looking good"
[17571] Started: -./alarmMe.pl 1 "Things aren't looking good"
[17571] Exit(0)
> quit
$
@end smallexample
@end cartouche

@node Rule Files
@subsection Rule Files (Scripts) 

A rule file is just a file that contains NodeBrain rules. By convention, use a @code{.nb} suffix on these files.  You can combine what you've learned in this section into a rule file named @code{roger.nb}.

@cartouche
@smallexample
# roger.nb
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes"
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes"
define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
@end smallexample
@end cartouche

When you specify a file as an argument to NodeBrain, it reads the file and processes the commands.

@cartouche
@smallexample
$ nb roger.nb
2014-06-12 22:11:01  NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2014-06-12 22:11:01 NB000I Source file "roger.nb" included. size=241
2014-06-12 22:11:01 NB000I NodeBrain nb[26914] terminating - exit code=0
$
@end smallexample
@end cartouche

But wait, this is a tutorial on interactive sessions.  What happened to the prompt?
Remember that NodeBrain assumes you want an interactive session when you don't specify any arguments?
Well, when you specify a file, NodeBrain assumes you want a batch session and just processes the file and quits.

To tell NodeBrain you want an interactive session after the file is processed, you need to give it an additional @code{-} argument.

@cartouche
@smallexample
$ nb roger.nb -
2009/03/16 11:32:35 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2014-06-12 22:11:44 NB000I Source file "roger.nb" included. size=241
2014-06-12 22:11:44 NB000I Argument [2] -
2014-06-12 22:11:44 NB000I Reading from standard input.
---------- --------
> @b{assert a=1,b=2;}
2014-06-12 22:11:49 NB000I Rule myProcessRule3 fired 
: -:./processCount.pl
[26916] Started: -:./processCount.pl
[26916: assert processes=32;
2014-06-12 22:11:49 NB000I Rule myProcessRule2 fired 
: -./alarmMe.pl 2 "ok - under 100 processes."
[26921] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[26921] Exit(0)
[26916] Exit(0)
> @b{quit}
2009/03/16 11:32:52 NB000I NodeBrain nb[3514] terminating - exit code=0
@end smallexample
@end cartouche

@node Batch Mode
@section Batch Mode    

Except for the user prompt, everything you learned in the previous section on interactive sessions applies to batch sessions.  The rules are the same; you just no longer assume a user is typing commands.

@subsection Starting and Stopping a Batch Session

In the previous section, you actually ran a batch session by accident.

@cartouche
@smallexample
$ nb roger.nb
2014-06-12 22:11:01  NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2014-06-12 22:11:01 NB000I Source file "roger.nb" included. size=241
2014-06-12 22:11:01 NB000I NodeBrain nb[26914] terminating - exit code=0
$
@end smallexample
@end cartouche

You start a batch session by giving @code{nb} at least one source file without specifying the @code{-} option.  A batch session ends when all source files have been processed.

Create a second source file with some assertions. Call it @code{abby.nb}.

@cartouche
@smallexample
# abby.nb
assert a=1,b=3;
assert b=2;
assert a=0;
assert a=1;
@b{@ }
@end smallexample
@end cartouche

Combine the rule file and assertions in a single batch session.

@cartouche
@smallexample
@b{@ }
$ nb roger.nb abby.nb
2014-06-12 22:49:15 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2014-06-12 22:49:15 NB000I Source file "roger.nb" included. size=241
2014-06-12 22:49:15 NB000I Argument [2] abby.nb
> # abby.nb
> assert a=1,b=3;
> assert b=2;
2014-06-12 22:49:15 NB000I Rule myProcessRule3 fired 
: -:./processCount.pl
[27372] Started: -:./processCount.pl
[27372: assert processes=32;
2014-06-12 22:49:15 NB000I Rule myProcessRule2 fired 
: -./alarmMe.pl 2 "ok - under 100 processes."
[27376] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[27376] Exit(0)
[27372] Exit(0)
> assert a=0;
> assert a=1;
2014-06-12 22:49:15 NB000I Rule myProcessRule3 fired 
: -:./processCount.pl
[27382] Started: -:./processCount.pl
[27382: assert processes=32;
[27382] Exit(0)
2014-06-12 22:49:15 NB000I Source file "abby.nb" included. size=57
2014-06-12 22:49:15 NB000I NodeBrain nb[27371] terminating - exit code=0
$
@end smallexample
@end cartouche

This time the batch session generated an alarm saying "ok - under 100 processes."  Do you know why rule @code{myProcessRule3} fired twice, but rule @code{myProcessRule2} only fired once?  The rule condition for @code{myProcessRule3} transitioned to a true state twice, while the condition for @code{myProcessRule2} only transitioned to a true state once.  An @code{on} rule whose condition is true will not fire when a new assertion causes it to remain true. 

@subsection Piping Commands to a Batch Session

If you give NodeBrain an equals sign (@code{=}) as an argument, it processes @code{stdin} like any other file.  Do the same thing you did in the previous example using a pipe to @code{stdin}.

@cartouche
@smallexample
$ cat roger.nb abby.nb | nb =
@end smallexample
@end cartouche

You can combine the @code{=} argument with other source file arguments.

@cartouche
@smallexample
$ cat abby.nb | nb roger.nb =
@end smallexample
@end cartouche

Files are processed in the order of arguments.  If you change the argument order, the assertions are made before you define the rules, so you don't get the same results.

@cartouche
@smallexample
$ cat abby.nb | nb = roger.nb
@end smallexample
@end cartouche

This is like specifying the following command.

@cartouche
@smallexample
$ nb abby.nb roger.nb
@end smallexample
@end cartouche

Okay, so you now know how to pipe commands into NodeBrain. Maybe it would be handy to use a script as the source of assertions.  Here's a script called @code{randy.pl} that will generate some pseudo random values for a and b.

@cartouche
@smallexample
randy.pl
#!/usr/bin/perl
for($i=1;$i<10;$i++)@{
  $r=int(rand()*4);
  if($r%2)@{print("assert a=$r;\n");@}
  else@{print("assert b=$r;\n");@}
  @}
@end smallexample
@end cartouche

You can use this script as the source of your assertions by piping the output of the script to NodeBrain.

@cartouche
@smallexample
$ ./randy.pl | nb roger.nb =
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2014-06-12 23:11:34 NB000I Source file "roger.nb" included. size=243
2014-06-12 23:11:34 NB000I Argument [2] =
2014-06-12 23:11:34 NB000I Reading from standard input.
---------- --------
| assert b=2;
| assert a=1;
2014-06-12 23:11:34 NB000I Rule myProcessRule3 fired 
: -:./processCount.pl
[27890] Started: -:./processCount.pl
[27890: assert processes=32;
2014-06-12 23:11:34 NB000I Rule myProcessRule2 fired 
: -./alarmMe.pl 2 "ok - under 100 processes."
[27895] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[27895] Exit(0)
[27890] Exit(0)
| assert b=2;
| assert a=1;
| assert b=0;
| assert b=2;
2014-06-12 23:11:34 NB000I Rule myProcessRule3 fired 
: -:./processCount.pl
[27901] Started: -:./processCount.pl
[27901: assert processes=32;
[27901] Exit(0)
| assert a=1;
| assert a=1;
| assert b=0;
2014-06-12 23:11:34 NB000I NodeBrain nb[27889] terminating - exit code=0
$
@end smallexample
@end cartouche

You can also pipe from within a script.  In @code{randal.pl}, you open a pipe to NodeBrain and write to the pipe.

@cartouche
@smallexample
randal.pl
#!/usr/bin/perl
@b{open(NB,"|nb roger.nb =")||die;}
for($i=1;$i<10;$i++)@{
  $r=int(rand()*4);
  if($r%2)@{print(@b{NB} "assert a=$r;\n");@}
  else@{print(@b{NB} "assert b=$r;\n");@}
  @}
@b{close(NB);}
@end smallexample
@end cartouche

The result is the same.

@cartouche
@smallexample
$ ./randal.pl
2014-06-12 23:14:55 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2014-06-12 23:14:55 NB000I Source file "roger.nb" included. size=243
2014-06-12 23:14:55 NB000I Argument [2] =
2014-06-12 23:14:55 NB000I Reading from standard input.
---------- --------
| assert a=3;
| assert a=1;
| assert a=3;
| assert a=1;
| assert a=3;
| assert a=1;
| assert b=2;
2014-06-12 23:14:55 NB000I Rule myProcessRule3 fired 
: -:./processCount.pl
[27913] Started: -:./processCount.pl
[27913: assert processes=33;
2014-06-12 23:14:55 NB000I Rule myProcessRule2 fired 
: -./alarmMe.pl 2 "ok - under 100 processes."
[27918] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[27918] Exit(0)
[27913] Exit(0)
| assert b=0;
| assert a=1;
2014-06-12 23:14:55 NB000I NodeBrain nb[27912] terminating - exit code=0
$
@end smallexample
@end cartouche

So, any way you can establish a pipe to NodeBrain is fine, just remember to tell NodeBrain to read @code{stdin} by specifying @code{=} as a file argument.

@node Servant Mode
@section Servant Mode

@quotation
@i{If thou are a master, be sometimes blind; if a servant, sometimes deaf.} ---Thomas Fuller (1608--1661)
@end quotation

When NodeBrain reads commands from @code{stdin} in batch mode, it uses blocking I/O.
This means it does nothing while waiting for the next command from the master.  If the master is mute, NodeBrain is an idle slave.  In servant mode, NodeBrain reads @code{stdin} using non-blocking I/O and is free to perform other duties while waiting for the next command from the master.

@subsection Scheduling Rules

Let's first learn a simple way to give NodeBrain something else to do while waiting for commands.  Here's a rule file like @code{roger.nb} that includes a scheduling rule.  Call it @code{jeeves.nb}.

@cartouche
@smallexample
# jeeves.nb
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
@b{define mySchedulingRule on(~(3s)) a=0;}
@end smallexample
@end cartouche

The rule condition @code{~(3s)} specifies that the rule should fire every 3 seconds.  When the @code{mySchedulingRule} fires, it asserts that a=0.  If NodeBrain is waiting on input from @code{stdin}, it cannot trigger this rule as specified.  So you have to change the way NodeBrain runs.

@subsection Servant Option

Here's a script called @code{bertie.pl} that uses the @code{-s} option to put NodeBrain in servant mode once all the input files specified as arguments have been processed.

@cartouche
@smallexample
bertie.pl
#!/usr/bin/perl
use FileHandle;
open(NB,"|nb jeeves.nb @b{-s}")||die;  # use servant option
NB->autoflush(1); # force output to nb as soon as we send a command
for($i=1;$i<10;$i++)@{
  $r=int(rand()*4);
  if($r%2)@{print(NB "assert a=$r;\n");@}
  else@{print(NB "assert b=$r;\n");@}
  @b{sleep(5);}             # pretend like we are busy working on something
  @}
@b{print(NB "stop\n");}    # stop the servant mode nb
close(NB);
@end smallexample
@end cartouche

You can see from the output below that the activity scheduled by @code{mySchedulingRule} is taking place between commands sent by @code{bertie.pl}.   

@cartouche
@smallexample
$ ./bertie.pl
2008/06/05 21:31:00 NB000I Argument [1] jeeves.nb
> # jeeves.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
> define mySchedulingRule on(~(3s)) a=0;
2008/06/05 21:31:00 NB000I Source file "jeeves.nb" included. size=283
2008/06/05 21:31:00 NB000I Argument [2] -s
2008/06/05 21:31:00 NB000T Servant mode selected
---------- ----------------------------------------------------
> assert a=3;
2008/06/05 21:31:03 NB000I Rule mySchedulingRule fired (a=0)
> assert b=0;
2008/06/05 21:31:06 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:09 NB000I Rule mySchedulingRule fired (a=0)
> assert a=3;
2008/06/05 21:31:12 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:15 NB000I Rule mySchedulingRule fired (a=0)
> assert b=2;
2008/06/05 21:31:18 NB000I Rule mySchedulingRule fired (a=0)
> assert b=0;
2008/06/05 21:31:21 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:24 NB000I Rule mySchedulingRule fired (a=0)
> assert a=3;
2008/06/05 21:31:27 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:30 NB000I Rule mySchedulingRule fired (a=0)
> assert b=2;
2008/06/05 21:31:33 NB000I Rule mySchedulingRule fired (a=0)
> assert b=2;
2008/06/05 21:31:36 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:39 NB000I Rule mySchedulingRule fired (a=0)
> assert a=1;
2008/06/05 21:31:40 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7537] Started: -:./processCount.pl
[7537: assert processes=59;
2008/06/05 21:31:40 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[7541] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[7541] Exit(0)
[7537] Exit(0)
2008/06/05 21:31:43 NB000I Rule mySchedulingRulefired (a=0)
2008/06/05 21:31:45 NB000I Rule mySchedulingRulefired (a=0)
> stop
2008/06/05 21:31:45 NB000I NodeBrain nb[7536] terminating - exit code=0
$
@end smallexample
@end cartouche

@node Agent Mode
@section Agent Mode

Monitoring applications normally require a program that runs constantly and mostly without user control but acts on the user's behalf. These qualities of persistence, relative autonomy, and user-directed goals are characteristic of a software agent.  These programs are known as as daemons on Unix or Linux, and services on Windows.

Let's modify the rules from the previous example so the program can execute the process counting script every minute.   

@cartouche
@smallexample
# maxwell.nb
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
define myProcessRule3 on(~(m)):-:./processCount.pl
@end smallexample
@end cartouche

Now you'll execute it.

@cartouche
@smallexample
$ nb maxwell.nb
2008/06/05 21:45:53 NB000I Argument [1] maxwell.nb
> # maxwell.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> # check process count every minute
> define myProcessRule3 on(~(m)):-:./processCount.pl
2008/06/05 21:45:53 NB000I Source file "maxwell.nb" included. size=273
2008/06/05 21:45:53 NB000I NodeBrain nb[7618] terminating - exit code=0
$
@end smallexample
@end cartouche

But wait, that's not right.  The program just ended after loading the rules.  You need a way to tell it to run as a daemon.  Try the daemon option @code{-d}.
 
@cartouche
@smallexample
$ nb .d maxwell.nb
2008/06/05 21:47:28 NB000I Argument [1] -d
2008/06/05 21:47:28 NB000I Argument [2] maxwell.nb
> # maxwell.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> # check process count every minute
> define myProcessRule3 on(~(m)):-:./processCount.pl
2008/06/05 21:47:28 NB000I Source file "maxwell.nb" included. size=273
2008/06/05 21:47:28 NB000I NodeBrain nb[@b{7621},7060]daemonizing
$
@end smallexample
@end cartouche

Okay, that's better, it daemonized.  It disconnected from the terminal and is running in the background with no @code{stdin} or @code{stdout}.  It actually forks a new process to run as the daemon and then ends.

@cartouche
@smallexample
$ ps -ef | grep nb
myuser   @b{7622}     1  0 21:47 ?       00:00:00 nb -d maxwell.nb
@end smallexample
@end cartouche

Well, you have an agent running now, but you don't have any way to see what it is doing.  For better visibility, you need to instruct NodeBrain to write to a log file.  While you're at it, make it an executable script by adding a she-bang line.  Guess you should stop the running agent also.

@cartouche
@smallexample
$ kill 7622
@end smallexample
@end cartouche

Here's the enhanced agent called @code{james.nb}.
 
@cartouche
@smallexample
#!/usr/local/bin/nb -d
# james.nb
set log="james.log";
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
# check process count every minute
define myProcessRule3 on(~(m)):-:./processCount.pl
@end smallexample
@end cartouche

If you want to execute it, set the file permissions.

@cartouche
@smallexample
$chmod 755 james.nb
@end smallexample
@end cartouche

Now let's start it.

@cartouche
@smallexample
$ ./james.nb
2008/06/05 21:55:31 NB000I Argument [1] -d
2008/06/05 21:55:31 NB000I Argument [2] ./james.nb
> #!/usr/local/bin/nb -d
> # james.nb
> set log="james.log";
2008/06/05 21:55:31 NB000I NodeBrain nb will log to james.log
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> # check process count every minute
> define myProcessRule3 on(~(m)):-:./processCount.pl
2008/06/05 21:55:31 NB000I Source file "./james.nb" included. size=370
2008/06/05 21:55:31 NB000I NodeBrain nb[7688,7060] daemonizing
$
@end smallexample
@end cartouche

Now you can see what the agent is doing by tailing the log file.  Wait a minute, it isn't doing much.  Yes, wait another minute.  

@cartouche
@smallexample
$ tail james.log
2009/01/28 09:04:26 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[5619] Started: -:./processCount.pl
[5619: assert processes=75;
2009/01/28 09:04:26 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[5623] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[5623] Exit(0)
[5619] Exit(0)
2009/01/28 09:05:00 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[5648] Started: -:./processCount.pl
[5648: assert processes=78;
[5648] Exit(0)
2009/01/28 09:06:00 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[5659] Started: -:./processCount.pl
[5659: assert processes=78;
[5659] Exit(0)
@end smallexample
@end cartouche

The log tells you the scheduled process is running and that 78 active processes on this system.  If the count goes over 200, you will be notified by @code{rule myProcessRule1} via the @code{alarmMe.pl} script.

That's it---you have a working agent.  But clearly this example was not designed to convince you that NodeBrain should be used when the application is this simple.  This entire problem could be solved with one simple script written in your favorite scripting language.  NodeBrain is appropriate for situations where there is a benefit to separating declarative rules from procedural logic in a modular fashion.  It may take experimentation with more complex and evolving agent requirements to appreciate when it is appropriate.

@node Cell Formulas
@chapter Cell Formulas
@cindex cell formulas

@quotation
@i{I like nonsense; it wakes up the brain cells.}
---Dr. Seuss (1904--1991)
@end quotation

What could be more nonsensical than a program called NodeBrain?  And of course, if I claim this program is a brain, there must be brain cells and a way to wake them up.  So here goes.

You can think of a cell as a structure capable of storing a value and optionally a formula for computing a value.  You may be familiar with this notion if you use a spreadsheet program.  A NodeBrain cell is vary similar to a spreadsheet cell, but without the tabular model.  There is no physical relationship between NodeBrain cells; no notions like "two to the left" or "one cell up."  NodeBrain cells are referenced only by their formula, which is called a cell formula.

Cell formulas are allowed in various places within the command syntax.
I can't tell you where exactly because I promised not to get BNF (Backus-Naur Form) on you here, but I can say cell definitions, assertions, and rule conditions are the primary places where cell formulas are used.

@menu
* Numbers and Strings::
* Arithmetic::
* Logic::
* Time Conditions::
* Node Sentence Formulas::
* Complex Formulas::
@end menu

@node Numbers and Strings
@section Numbers and Strings

The simplest cell formulas identify a literal number or string.  Here you define a cell @code{a} with the formula @code{5}, and a cell @code{b} with the formula @code{"abc"}.

@cartouche
@smallexample
$ nb
> define a cell 5;
> define b cell "abc";
> show a
a = 5
> show b
b = "abc"
> @ 
@end smallexample
@end cartouche

@node Arithmetic
@section Arithmetic

NodeBrain can do simple arithmetic in a cell.

@cartouche
@smallexample
$ nb
> define a cell 5+4;
> define b cell a+3;
> show a
a = ! == (5+4)
> show b
b = ! == (a+3)
> @ 
@end smallexample
@end cartouche

Wait, this must not be what Dr. Seuss meant by nonsense because these brain cells don't seem to be awake!  NodeBrain accepted the formula @code{5+4} but didn't compute @code{9}.  This is because NodeBrain is lazy. Nobody cares what the value of @code{a} or @code{b} is, so NodeBrain doesn't bother to compute them.
You need more nonsense to wake up these brain cells.
Let's try adding a rule that depends on the value of @code{b}.

@cartouche
@smallexample
> define rule1 on(b<20);
> show a
a = 9 == (5+4)
> show b
b = 12 == (a+3)
@end smallexample
@end cartouche

When you added the rule referencing @code{b}, NodeBrain was motivated to compute the value of @code{a+3}.  To get the value of @code{a}, it computes the value of @code{5+4}.

The double equals signs symbol (@code{==}) can be read as "is defined as."  The response to @code{show b} above can be read as "@code{b} is @code{12} and is defined as @code{a+3}."

Just for fun, let's see what happens when you assert new cell formulas for @code{a}.

@cartouche
@smallexample
> assert a=19;
> show a
a = 19
> show b
b = 22 == (a+3)
@b{>assert a=1;}
@b{2008/06/05 22:04:51 NB000I Rule rule1 fired}
> show b
b = 4 == (a+3)
> assert a=5*15/7+2;
> show a
a = 12.71428571
> @ 
@end smallexample
@end cartouche

Although you are on the topic of arithmetic, it is perhaps less interesting that NodeBrain does arithmetic than when it does it.
When you asserted that @code{a=1}, NodeBrain recomputed @code{b} and got @code{4}.  It then recomputed @code{b<20}, which transitioned from false to true and @code{rule1} fired.

@node Logic
@section Logic

@quotation
@i{Logic is like the sword---those who appeal to it shall perish by it.}
---Samuel Butler (1835--1902)
@end quotation

One can appeal to logic in cell formulas, much as in other programming languages.  Some familiar operators are illustrated here.

@cartouche
@smallexample
> assert a=1,b=2,c=3,d=3;
> define x cell a>b;
> define rule2 on(a=b or b=c or c>25);
> define rule3 on(a=21 and (b>5 or c<2));
> define rule4 on(x and !(a<5.73));
> define rule5 on(a=b and c=d);
@end smallexample
@end cartouche

Relational operators (@code{>  <  <>  = >= <=}) have precedence over trinary logic operators (@code{and}, @code{or}, @code{not}).  Use parentheses to force the order of precedence when you don't want or don't know the default.  

As demonstrated with arithmetic formulas, NodeBrain evaluates cells when there are assertions that change the value of operands.
For example, consider the following formula used by @code{rule5}.

@cartouche
@smallexample
a=b and c=d
@end smallexample
@end cartouche

If you assert that @code{a=3}, the interpreter has to recomputed @code{a=b}, but doesn't recompute the larger formula @code{a=b and c=d}.  Since @code{c} and @code{d} didn't change, the value of @code{c=d} has not changed, and since @code{a=b} remains false, the value of the larger formula is known to be unchanged without further computation.  

There is only one cell for computing any given formula.
No matter how many rule conditions reference @code{a=b}, there is only one @code{a=b} cell, as there is only one @code{a} cell and one @code{b} cell.
Every cell knows which cells reference it.
In this example, both @code{a} and @code{b} know that @code{a=b} depends on them.
If @code{a} changes, it reports a change to @code{a=b}.
If @code{b} changes, it does the same.
If @code{a} changes, @code{b} changes, or both @code{a} and @code{b} change in the same assertion, @code{a=b} is recomputed once.
If @code{a=b} changes, cells that reference it are recomputed.

How do you think the interpreter would respond to the following assertion?

@cartouche
@smallexample
assert a=21,b=21.
@end smallexample
@end cartouche

Because either of @code{a} or @code{b} has changed (in this case both), the interpreter must evaluate @code{a=b} again.
Since the value is still true, no further computation is required.

@node Time Conditions
@section Time Conditions

@quotation
@i{I must govern the clock, not be governed by it.}
---Golda Meir (1898--1978)
@end quotation

NodeBrain is happy to be governed by the clock.
It has an extensive algebra for expressing schedules called time conditions.
A time condition is a function of time that is true or false at any given second.  

In the spirit of this tutorial, I have been deliberately incomplete here and give you a sense of it.
I'm somewhat proud of this feature, so I've exercised conscious restraint.  (If you need a cure for insomnia, read about time conditions in the @i{NodeBrain Language Reference}.)

I'll just jump into it with a few examples.  The following script, @code{schedule.nb}, has rules with names describing their time condition. Let's start it in interactive mode.

@cartouche
@smallexample
$ nb schedule.nb -
2008/06/06 06:38:14 NB000I Argument [1] schedule.nb
> define FourOClockHour on(~(h(4)));
> define MondayWednesayAndFriday on(~(mo,we,fr));
2008/06/06 06:38:14 NB000I Rule MondayWednesayAndFriday fired
> define Four2FiveMonWedFri on(~(h(4).(mo,we,fr)));
> define January9 on(~(jan(9)));
> define WeekOfJanuary15 on(~(w.jan(15)));
> define ThursdayOfWeekOfJanuary15 on(~(th.w.jan(15)));
> define LastFridayInJanuary on(~(fr[-1]jan));
> define TuesdayOfWeekOfLastFridayInJanuary on(~(tu.w.fr[-1]jan));
2008/06/06 06:38:14 NB000I Source file "schedule.nb" included. size=371
2008/06/06 06:38:14 NB000I Argument [2] -
2008/06/06 06:38:14 NB000I Reading from standard input.
---------- --------
>
@end smallexample
@end cartouche

To see the next event for each schedule, use the @code{show} command with a @code{/c} (clock) option.
I issued this command at 6:41 on Friday, June 6, 2008.  The @code{h(4)} condition will transition to true at 04:00, and then back to false at 05:00.  The @code{(mo,we,fr)} condition will transition to true at 00:00 Monday the 9th.  See if you can make sense out of the rest of the conditions in this list, given the hint that weeks start at 00:00 Sunday. Match the conditions to the name of the corresponding rule above if you need help.    

@cartouche
@smallexample
> show /c
~ 2008/06/06 06:41:17 Clock
~ 2008/06/07 00:00:00 ~(mo,we,fr)
                      on(~(mo,we,fr));
~ 2008/06/07 04:00:00 ~(h(4))
                      on(~(h(4)));
~ 2008/06/09 04:00:00 ~(h(4).(mo,we,fr))
                      on(~(h(4).(mo,we,fr)));
~ 2009/01/09 00:00:00 ~(jan(9))
                      on(~(jan(9)));
~ 2009/01/11 00:00:00 ~(w.jan(15))
                      on(~(w.jan(15)));
~ 2009/01/15 00:00:00 ~(th.w.jan(15))
                      on(~(th.w.jan(15)));
~ 2009/01/27 00:00:00 ~(tu.w.fr[-1]jan)
                      on(~(tu.w.fr[-1]jan));
~ 2009/01/30 00:00:00 ~(fr[-1]jan)
                      on(~(fr[-1]jan));
@end smallexample
@end cartouche

A @code{forecast} command is used to see when a time condition will transition to true (left column) and false (right column).

@cartouche
@smallexample
> @b{forecast ~(mo,we,fr)}
mo,we,fr schedule ~0-0 interval=0,duration=0)
fr 2008/06/06 00:00:00 1212735600 - sa 2008/06/0700:00:00 1212822000
mo 2008/06/09 00:00:00 1212994800 - tu 2008/06/1000:00:00 1213081200
we 2008/06/11 00:00:00 1213167600 - th 2008/06/1200:00:00 1213254000
fr 2008/06/13 00:00:00 1213340400 - sa 2008/06/1400:00:00 1213426800
mo 2008/06/16 00:00:00 1213599600 - tu 2008/06/1700:00:00 1213686000
we 2008/06/18 00:00:00 1213772400 - th 2008/06/1900:00:00 1213858800
> @b{forecast ~(h(4));}
h(4) schedule ~0-0 interval=0,duration=0)
sa 2008/06/07 04:00:00 1212836400 - sa 2008/06/0705:00:00 1212840000
su 2008/06/08 04:00:00 1212922800 - su 2008/06/0805:00:00 1212926400
mo 2008/06/09 04:00:00 1213009200 - mo 2008/06/0905:00:00 1213012800
tu 2008/06/10 04:00:00 1213095600 - tu 2008/06/1005:00:00 1213099200
we 2008/06/11 04:00:00 1213182000 - we 2008/06/1105:00:00 1213185600
th 2008/06/12 04:00:00 1213268400 - th 2008/06/1205:00:00 1213272000
@end smallexample
@end cartouche

The fundamental concepts to grasp here are that time conditions have

@enumerate
@item
Identifiers like @code{mo} for Monday, @code{h} for hour, @code{jan} for January, and @code{w} for week that define a set of time intervals
@item
Operators (@code{,} @code{.} @code{(n)} @code{[n]}) that operate on time interval sets to produce new sets
@end enumerate

The operators are based on formal concepts like intersection, union, selection, rejection, inverse, and so on.        

@node Node Sentence Formulas
@section Node Sentence Formulas 

@quotation
@i{An expert knows all the answers---if you ask the right questions.}
---Unknown
@end quotation

A NodeBrain node is an expert, with a set of knowledge and associated skill.  The skill is provided by a node module (plug-in) that extends NodeBrain functionality.  Since NodeBrain is not a general purpose scripting language, many things are simply inappropriate to attempt without help from a node module.  It is the combination of skill and knowledge that makes a node an expert.  Of course, you need to know how to ask the right questions.

Node modules can be developed to perform any function imaginable, but within the context of a cell formula they only provide the value of node sentence formulas.  These formulas look like a function call.  In rule @code{r1} below, @code{sally(x)} is a node sentence formula and @code{sally} is a node with the skills provided by the tree module.

@cartouche
@smallexample
$ nb sally.nb
2008/06/06 07:05:49 NB000I Argument [1] sally.nb
> # sally.nb
> define sally node tree;
> assert sally("abc"),sally("def",5)=2;
> show sally
sally = ! == node tree
  "def"
    5=2
  "abc"=1
> define r1 on(sally(x));
> assert x="abc";
2008/06/06 07:05:49 NB000I Rule r1 fired
@end smallexample
@end cartouche

Do you see why rule @code{r1} fired when you asserted that @code{x="abc"}? It is because @code{sally("abc")} was asserted to be true, so @code{sally(x)} is true when @code{x="abc"}.  What a node module does with assertions and how it computes the value of node sentence formulas is entirely up to it.  In this case, the @code{tree} node module keeps track of assertions and returns a value for formulas by doing a lookup.  When the value of @code{x} changes, the interpreter reports a change to the node module and it computes a new value for the cell.
When the cell value changes, it reports a change to the referencing cells, in this case rule @code{r1}, which fired.

@node Complex Formulas
@section Complex Formulas

@quotation
@i{A complex system that works is invariably found to have evolved from a simple system that works.}
---John Gaule (c. 1603--1687)
@end quotation

Every type of cell formula introduced in this tutorial can be combined into complex formulas as illustrated by rule @code{complex} below.

@cartouche
@smallexample
$ nb complex.nb
2008/06/06 07:14:28 NB000I Argument [1] complex.nb
> # complex.nb
> define sally node tree;
> assert sally("abc"),sally("def",5)=2;
> define complex on(sally(x,y)=a+b and y<7 and ~(fr));
> assert y=5;
> assert a,b;
> assert x="def";
2008/06/06 07:14:28 NB000I Rule complex fired
@end smallexample
@end cartouche

If the complex rule doesn't fire when you run @code{complex.nb}, perhaps you are not running it on a Friday.
If you try it on a Friday, it will fire because @code{y<7} is true and @code{sally(x,y)=a+b} is true.  
The fact that this condition is true may not be so obvious, so let's break it down.  The command @code{assert a,b;}
sets @code{a} and @code{b} to 1 (true).  That means the cell @code{a+b} is 2.  Since @code{x} is @code{"def"} and @code{y} is 5, the cell @code{sally(x,y)=a+b} is the same as @code{sally("def",5)=2}, which you assert to be true.

@node Ignorance
@chapter Ignorance
@cindex unknown value
@cindex true value
@cindex false value
@cindex special value, unknown
@cindex special value, true
@cindex special value, false

@quotation
@i{Ignorance more frequently begets confidence than does knowledge.}
---Charles Darwin (1809--1882)
@end quotation

This tutorial is about ignorance: when NodeBrain is aware of it and how it is handled.  It is perhaps obvious, but important to remember, that NodeBrain assumes that whatever is asserted is the truth.  It makes no attempt to independently verify assertions, or check whether assertions should have been made that were not.  So what NodeBrain thinks it knows may not be the truth.  In this respect, NodeBrain is unaware of its ignorance and blissfully acts with great confidence.  No different than most of us.

However, within NodeBrain's own version of reality, it can be aware of a form of ignorance.  The notion here is that something can be known to be unknown, a possibility often dismissed by people rushing to judgment.
How NodeBrain deals with that condition is the topic of this tutorial.

@menu
* True False Unknown::
* Closed World Assumption::
* Reactive Mode::
* Query Mode::
@end menu

@node True False Unknown
@section True, False, and Unknown

@quotation
@i{Something unknown is doing we don't know what.}
---Sir Arthur Eddington (1882--1944)
@end quotation

The NodeBrain interpreter recognizes three logical states: true, false, and unknown.  These states are represented as follows.

@quotation
@multitable {-------------} {-----------------------------------------------------------------------}
@item @b{Value} @tab @b{Representation}
@item Unknown @tab ?
@item False   @tab 0
@item True    @tab 1 or anything else (e.g., 5.2, --7, "abc", "")
@end multitable
@end quotation

You can test for these states by using the @code{=} relational operator or a prefix operator. The @code{!} prefix operator means "not" and the @code{?} prefix operator means "is unknown."
 
@cartouche
@smallexample
> define r1 on(a=1 and b=0 and c=? and x and !y and ?z);
@end smallexample
@end cartouche

Values can be asserted similarly.

@cartouche
@smallexample
$ nb
> assert a=1,b=0,c=?,x,!y,?z;
> show -t
@@ =! == node
z =?
y =0
x =1
c =?
b =0
a =1
> @ 
@end smallexample
@end cartouche

Although anything other than @code{?} or @code{0} is interpreted as true, logical operators often return a value of @code{1} to represent a true state. Below you see that the value of @code{a<b} is @code{1}.

@cartouche
@smallexample
> assert a=5,b=7;
> define r1 on(a<b);
> show (a<b)
()= @b{1} == (@b{a<b})
@end smallexample
@end cartouche

Here's the important thing to understand.  Logical operators accept the unknown value as an operand and return the unknown value under specific conditions.  Logic tables for @code{A and B} and @code{A or B} are shown below. Notice that in some cases NodeBrain knows the result without knowing both operands.

@quotation
@multitable {---} {---} {------} {------}
@item   @b{A} @tab @b{B} @tab @b{A&B} @tab @b{A|B}
@item   0 @tab 0 @tab  0  @tab  0
@item   0 @tab 1 @tab  0  @tab  1
@item   0 @tab ? @tab  0  @tab  ?
@item   1 @tab 0 @tab  0  @tab  1
@item   1 @tab 1 @tab  1  @tab  1
@item   1 @tab ? @tab  ?  @tab  1
@item   ? @tab 0 @tab  0  @tab  ?
@item   ? @tab 1 @tab  ?  @tab  1
@item   ? @tab ? @tab  ?  @tab  ?
@end multitable
@end quotation

The @code{?} prefix operator enables you to test for an unknown condition and act on it.

@cartouche
@smallexample
$ nb
> define x cell a+b;
> define r1 on(?x);
> assert a=7,b=12;
> show -t
@@ =! == node
r1= ! == on(?x);
x =19 == (a+b)
b =12
a =7
> assert ?b;
2008/06/0607:41:34 NB000I Rule r1 fired
> 
@end smallexample
@end cartouche

Let's pause to make sure you know what just happened here. The condition @code{?x} is true when @code{x} is unknown.  This was true when @code{r1} was defined because @code{x} is @code{@i{a}+@i{b}}and both @code{@i{a}} and @code{@i{b}} are unknown at that time.  Hey, the arithmetic operators understand the unknown value also.  When you assert that @code{a=7} and @code{b=12}, @code{x} was known to be 19 and @code{?x} was false.  Then you assert @code{?b}, making @code{a+b} unknown, making @code{x} unknown, making @code{?x} true and @code{r1} fired.
 
@node Closed World Assumption
@section Closed World Assumption

Some systems use a closed world assumption, where anything not known to be true is assumed to be false.  As  illustrated in the previous section, NodeBrain does not generally make this assumption.  Instead it allows the unknown state to propagate through the evaluation of cells.

However, node modules are allowed to handle the unknown state using either the closed world assumption or three-state logic.  This means you must be aware of how each node module handles the unknown state when coding rules.

I'll illustrate using two nodes, one with the @code{tree} skill and one with the @code{cache} skill.  The @code{tree} module uses three-state logic and the @code{cache} module uses the closed world assumption.

@cartouche
@smallexample
$ nb closedWorld.nb
2008/06/0607:44:05 NB000I Argument [1] closedWorld.nb
> define myTree expert tree;
> define myCache expert cache:(soup);
> define rMyTreeHasSoup on(myTree(soup));
> define rMyCacheHasSoup on(myCache(soup));
> define rMyTreeHasNotSoup on(!myTree(soup));
> define rMyCacheHasNotSoup on(!myCache(soup));
> define rMyTreeKnowsNotSoup on(?myTree(soup));
> define rMyCacheKnowsNotSoup on(?myCache(soup));
> assert myTree("Chicken"),myCache("Chicken");
> assert soup="Tomato"; 
> assert soup="Chicken";
2008/06/0607:44:05 NB000I Rule rMyCacheHasSoup fired
2008/06/0607:44:05 NB000I Rule rMyTreeHasSoup fired
> assert ?myTree("Chicken"),?myCache("Chicken");
2008/06/0607:44:05 NB000I Rule rMyTreeKnowsNotSoup fired
2008/06/0607:44:05 NB000I Rule rMyCacheHasNotSoup fired
> assert !myTree("Chicken"),!myCache("Chicken");
2008/06/0607:44:05 NB000I Rule rMyTreeHasNotSoup fired
2008/06/0607:44:05 NB000I Source file "closedWorld.nb" included. size=514
2008/06/0607:44:05 NB000I NodeBrain nb[13980] terminating - exit code=0
$
@end smallexample
@end cartouche

This may just be a blur, so let's take the assertions one at a time.  Initially, @code{soup} is unknown, @code{myTree(soup)} is unknown, and @code{myCache(soup)} is false.
The reason @code{myCache(soup)} is false is because the @code{cache} skill uses the closed world assumption; what is not known to be true is false. 
When you assert @code{"Chicken"} to both the @code{tree} and the @code{cache}, there is no change to the value of @code{myTree(soup)} and @code{myCache(soup)}.
When you assert that @code{soup="Tomato"}, there is still no change.  A value of @code{"Tomato"} is not known to @code{tree} or @code{cache}, in the same way an unknown soup is not known. 

Next, you assert that @code{soup="Chicken"}.  Both @code{myTree(soup)} and @code{myCache(soup)} transition to true and the corresponding rules @code{rMyCacheHasSoup} and @code{rMyTreeHasSoup} fire.

This is followed by an assertion that @code{myTree("Chicken")} and @code{myCache("Chicken")} are unknown.  Because the @code{cach} skill uses the closed world assumption, this is the same as asserting that @code{myCache("Chicken")} is false.  Consequently, @code{rMyCacheHasNotSoup} fires while @code{myTreeKnowsNotSoup} fires.

Finally, you assert @code{myTree("Chicken")} and @code{myCache("Chicken")} to be false.  This causes the rule @code{rMyTreeHasNotSoup} to fire.
There is no change to @code{myCache("Chicken")}, so no cache-related rule fires.

The difference between the @code{tree} and @code{cache} skills is that you must assert @code{myTree(soup)} to be false before @code{myTree(soup)} evaluates to false, while @code{myCache(soup)} is false simply because you haven't asserted it to be true.
Asserting either @code{!myCache("Chicken")} or @code{?myCache("Chicken")} removes knowledge of @code{"Chicken"} from the cache.
Only an assertion of @code{?myTree("Chicken")} removes knowledge of @code{"Chicken"} from the tree.
Asserting @code{!myTree("Chicken")} asserts a value of false to the @code{"Chicken"} entry in the tree.

@node Reactive Mode
@section Reactive Mode

In all the previous examples in this tutorial, the interpreter has been operating in reactive mode when processing rules.  In this mode, the interpreter waits for assertions and responds appropriately.  It makes no effort to convert unknown values into known values.  Consider the following example.

@cartouche
@smallexample
$ nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
>
@end smallexample
@end cartouche

The interpreter knows the value of processes is unknown and it does nothing to find out.  This is reasonable because you haven't asked it to and you haven't told it how.  These are possibilities covered in the next section.

@node Query Mode
@section Query Mode

There is an interpreter mode called @i{query} mode, in which NodeBrain attempts to solve for unknown values as required to obtain a known value for rule conditions.  This mode approximates what your doctor does when you go in with a medical problem, or your car mechanic does when you take your car in with a mechanical problem.
They ask you questions, and they ask themselves questions that they try to answer by running tests.  They attempt to diagnose your problem by applying rules and seeking values for parameters that are initially unknown.  They only ask the questions and run the tests that are necessary to arrive at a conclusion.
This helps to avoid running unnecessary expensive tests.

If you tell NodeBrain how to query for unknown values and ask it to solve for rule conditions that have an unknown value, it can diagnose or investigate with similar efficiency.

@subsection Query Rule Files

A query rule file is simply a rule file designed to be processed in query mode.  Here's a file named @code{illness.nb} that is a trivial (and not useful) query rule file.

@cartouche
@smallexample
# File: tutorial/Ignorance/illness.nb
define CommonCold on(cough and soreThroat);
define Flu on(fever and achy and upsetStomach);
@end smallexample
@end cartouche

As you can see, these query rules have the same syntax as reactive rules.   The difference is not in the rules, but in how you use them.  

@subsection Interactive Query Mode

Let's invoke this script in interactive mode and issue a @code{query} command. 

@cartouche
@smallexample
$ @b{nb illness.nb -}
> # File: tutorial/Ignorance/illness.nb
> define CommonCold on(cough and soreThroat);
> define Flu on(fever and achy and upsetStomach);
2008/06/10 15:51:44 NB000I Source file "illness.nb" included. size=111
2008/06/10 15:51:44 NB000I Argument [2] -
2008/06/10 15:51:44 NB000I Reading from standard input.
---------- --------
> @b{query}
 
  (fever&(achy&upsetStomach))
 
Enter cell fever==@b{0}
 
  (cough&soreThroat)
 
Enter cell cough==@b{1}

  (cough&soreThroat)
 
Enter cell soreThroat==@b{1}
2008/06/10 15:52:11 NB000I @b{Rule CommonCold fired}
> @ 
@end smallexample
@end cartouche

Since you are running in interactive mode and have not provided any alternate methods for NodeBrain to solve for unknown values, the interpreter prompts the user to resolve unknown values.  If you study the rule file, you will find five unknown terms in the two rule conditions: @code{cough}, @code{soreThroat}, @code{fever}, @code{achy}, and @code{upsetStomach}.  However, the interpreter only prompted the user for values of three of these terms.  This is because requesting values for the other two terms would not have changed the result.  Since @code{fever=0}, the @code{flu} condition is false for any value of the other two terms in the condition.

The response to each query may be any valid cell formula.  This means you must enclose strings in quotes and have the option of introducing new terms for which the interpreter does not have a value.  When new terms are introduced, the interpreter attempts to resolve them as necessary.  If you respond with @code{5 or soreEye}, the interpreter will not attempt to solve for @code{soreEye} because it knows the condition is true without knowledge of @code{soreEye}.

@subsection Batch Query Mode

In most applications of NodeBrain, you are attempting to automate decisions, so you want to query software to resolve unknowns where possible.
Here's a script called @code{illnessConsult.pl} that simulates the running of potentially complex tests to arrive at the same answers you provided interactively above.  There would be no point in doing something this simple for real, and no point in doing something more complicated in a tutorial.  You can imagine a much more complicated problem.  

@cartouche
@smallexample
#!/usr/bin/perl
# File: tutorial/Ignorance/illnessConsult.pl
$state@{"cough"@}=1;
$state@{"soreThroat"@}=1;
$state@{"fever"@}=0;
$state@{"achy"@}=1;
$state@{"upsetStomach"@}=0;

$symptom=shift;
if(exists($state@{$symptom@}))@{print("$state@{$symptom@}\n");@}
else@{print("?\n");@}
@end smallexample
@end cartouche
  
Let's run this script that you are pretending is complicated software to determine the value of the @code{cough} symptom.

@cartouche
@smallexample
$./illnessConsult.pl cough
1
@end smallexample
@end cartouche
 
Create a new rule file called @code{illnessConsult.nb} to consult the Perl script.

@cartouche
@smallexample
# File: tutorial/Ignorance/illnessConsult.nb
@b{use : ./illnessConsult.pl}
defineCommonCold on(cough and soreThroat);
defineFlu on(fever and achy and upsetStomach);
@b{query;}
@end smallexample
@end cartouche

Diagnose an illness in batch mode.

@cartouche
@smallexample
$ nb illnessConsult.nb
2008/06/1016:12:25 NB000I Argument [1] illnessConsult.nb
> # File: tutorial/Ignorance/illnessConsult.nb
> use : ./illnessConsult.pl
> define CommonCold on(cough and soreThroat);
> define Flu on(fever and achy and upsetStomach);
> query;
2008/06/1016:12:25 NB000T Resolving "fever" via command : ./illnessConsult.pl "fever"
Value=(0)
2008/06/1016:12:25 NB000T Resolving "cough" via command : ./illnessConsult.pl "cough"
Value=(1)
2008/06/1016:12:25 NB000T Resolving "soreThroat" via command : ./illnessConsult.pl "soreThroat"
Value=(1)
2008/06/1016:12:25 NB000I @b{Rule CommonCold fired}
2008/06/1016:12:25 NB000I Source file "illnessConsult.nb" included. size=149
2008/06/1016:12:25 NB000I NodeBrain nb[13690] terminating - exit code=0
$
@end smallexample
@end cartouche

In this example, the consulted script @code{illnessConsult.pl} returned simple 0 and 1 values.  The interpreter will accept any valid cell formula and will attempt to resolve any term whose value is both unknown and needed.

@node Rules
@chapter Rules
@cindex rules

@quotation
@i{If you obey all the rules, you miss all the fun.}
---Katharine Hepburn (1907--2003)
@end quotation

In this tutorial you'll see how much fun it is to make up rules and watch NodeBrain obey them.

@section When and If a Rule Fires on What

NodeBrain @code{on}, @code{when}, and @code{if} rules have almost identical syntax. Their conditional cell formulas are resolved by the same cell evaluation algorithm, yet they respond differently to new information.  You can study these differences using rules that have no action.  Start by creating the following script called @code{rules.nb}.

@cartouche
@smallexample
# File: tutorial/RuleTypes/rules.nb
define r0 when(a=1 and b=2);
define r1 on(a=1 and b=2);
define r2 on(a=2 and b=2);
define r3 if(a=1 and b=2);
assert a=1,b=2;
assert a=1,b=2;
assert a=2;
assert a=27;
alert a=1;
alert a=1;
@end smallexample
@end cartouche

When you execute this script you will notice that rules fire in response to assert and alert commands.

@cartouche
@smallexample
$ nb rules.nb
2008/06/1016:54:24 NB000I Argument [1] rules.nb
> # File: tutorial/RuleTypes/rules.nb
> define r0 when(a=1 and b=2);
> define r1 on(a=1 and b=2);
> define r2 on(a=2 and b=2);
> define r3 if(a=1 and b=2);
> assert a=1,b=2;
2008/06/1016:54:24 NB000I Rule r0 fired
2008/06/1016:54:24 NB000I Rule r1 fired
> assert a=1,b=2;
> assert a=2;
2008/06/1016:54:24 NB000I Rule r2 fired
> assert a=27;
> alert a=1;
2008/06/1016:54:24 NB000I Rule r1 fired
2008/06/1016:54:24 NB000I Rule r3 fired
> alert a=1;
2008/06/1016:54:24 NB000I Rule r3 fired
2008/06/1016:54:24 NB000I Source file "rules.nb" included. size=206
2008/06/1016:54:24 NB000I NodeBrain nb[13859] terminating - exit code=0
$
@end smallexample
@end cartouche

Although rules @code{r0}, @code{r1}, and @code{r3} are based on the same condition @code{(a=1 and b=2)}, they react differently to the @code{assert} and @code{alert} commands.

Q: Why didn't r3 fire on the first "@code{assert a=1,b=2;}" command?

A: Because @code{if} rules only respond to @code{alert} commands.

Q: Why didn't @code{r1} fire on the second @code{assert a=1,b=2;} command?

A: Because @code{on} rules only fire when their condition transitions to true.  The second assertion made no change in the state of the condition.

Q: Why didn't @code{r0} fire when @code{r1} fired the second time?

A: Because @code{when} rules only fire once.  They are removed from the rule set once they fire.


Q: Why did @code{r3} fire on the second @code{alert a=1;} command?

A: Because @code{if} rules fire on every @code{alert} command that leaves their condition in a true state.  Unlike @code{on} and @code{when} rules, they are not required to transition to a true state from a false or unknown state.

@section State Monitoring vs. Event Monitoring

In the previous example, you may have noticed that NodeBrain supports both state and event monitoring.  The difference between the two is subtle.
The @code{assert} command and @code{on} rule are designed for state monitoring.
The @code{alert} command and @code{if} rule are designed for event monitoring.  But it isn't that simple.
The @code{on} rule responds to both @code{assert} and @code{alert} commands.  To an @code{on} rule, @code{alert} is just an alias for @code{assert}.  In fact, everything about the way an @code{alert} command is processed is identical to the way an @code{assert} command is processed, except @code{alert} brings @code{if} rules into play.  In other words, @code{alert} makes an assertion, and then says, "Oh, and by the way, this is an event to be considered by the @code{if} rules."

What makes the notion of state and event monitoring hard to untangle is that an event is described in the same way as a state, an event is interpreted as a new state, a state change is recognized as an event, and a state change can trigger an event.
Let's look at these confusing statements individually.

@cartouche
@smallexample
# describe an event in the same way we describe a state
alert a=1,b=2;        # event
assert a=1,b=2;       # state 

# interpret an event as a new state
define r1 on(a=1 and b=2);
define r2 if(a=1 and b=2);
alert a=1,b=2;        # recognized as new state to both IF and ON rules
alert a=1,b=2;        # recognized as new state to IF rule, not to ON rule

# recognize state changes as events
define r1 on(a=1 and b=2);
assert a=0,b=0;
assert a=1,b=2;       # triggers internal events that cause r1 to fire

# translate state changes into events
define r1 on(a=1 and b=2): alert x="abc",y="def";
assert a=1,b=2;       # r1 translated state change into event(alert)
@end smallexample
@end cartouche

@section Actions as Reactions
@cindex actions
@cindex reactions

Rules are defined to react to state or event conditions with actions.
An action can be an assertion, a command, or a combination of both,
The following @code{on} rules have actions that use different approaches to
accomplish the same result.  These same actions could be used with @code{if} or @code{when} rules,
since their actions are specified in the same way.

@cartouche
@smallexample
define r1 on(a) x=5,y=2;         # action is assertion
define r2 on(b):assert x=5,y=2;  # action is assert command
define r3 on(c) x=5:assert y=2;  # action is assertion and assert command
assert a;
show x
show y
assert ?x,?y;
show x
show y
assert b;
show x
show y
assert ?x,?y;
show x
show y
assert c;
show x
show y
@end smallexample
@end cartouche

Copy the script above into a file named @code{xwise.nb} and execute it as illustrated below.

@cartouche
@smallexample
$ nb xwise.nb
> define r1 on(a) x=5,y=2;         # action is assertion
> define r2 on(b):assert x=5,y=2;  # action is assert command
> define r3 on(c) x=5:assert y=2;  # action is assertion and assert command
> assert a;
@b{2012/12/30 12:17:22 NB000I Rule r1 fired (x=5,y=2)}
> show x
x = 5
> show y
y = 2
> assert ?x,?y;
> show x
x = ?
> show y
y = ?
> assert b;
@b{2012/12/30 12:17:22 NB000I Rule r2 fired}
: @b{assert x=5,y=2;  # action is assert command}
> show x
x = 5
> show y
y = 2
> assert ?x,?y;
> show x
x = ?
> show y
y = ?
> assert c;
@b{2012/12/30 12:17:22 NB000I Rule r3 fired (x=5)}
: @b{assert y=2;  # action is assertion and assert command}
> show x
x = 5
> show y
y = 2
@end smallexample
@end cartouche

When making a simple assertion, a rule like @code{r1} above is the recommended approach because
the assertion is parsed when the rule is defined.  When using a command, as in @code{r2},
the command is not parsed until the rule fires. In @code{r3}, the @code{x=5} assertion
is parsed when the rule is defined, and the @code{assert y=2} command is parsed when the
rule fires.

A command action is required for a response other than a simple assertion, and even for an assertion when
symbolic substitution requires waiting until the rule fires to parse the assertion.

@cartouche
@smallexample
define r1 if(a):$ assert x="$@{n@} cases of $@{e@}";
assert n=5,e="something";
alert a;
@end smallexample
@end cartouche

Issue an @code{nb} command at a shell prompt and paste the example above at the NodeBrain prompt.
You should see the following.
@cartouche
@smallexample
$ nb
> define r1 if(a):$ assert x="$@{n@} cases of $x@{e@}";
> assert n=5,e="something";
> alert a;
2012/12/30 16:52:54 NB000I Rule r1 fired
: assert x="5 cases of something";
@end smallexample
@end cartouche

Use shell commands when the action can not be performed by NodeBrain directly.
Try this.

@cartouche
@smallexample
define r1 on(a):-|echo `date` ":it happened" >> happening.log;cat happening.log
assert a;
@end smallexample
@end cartouche

More complicated actions can be coded in your favorite scripting language or developed
as a compiled executable.

@node Syntax Surprises
@chapter Syntax Surprises
@cindex syntax, surprises

This section provides answers to some syntax questions.

@section When do I use a semi-colon to end a command?

@quotation
@i{From now on, ending a sentence with a preposition is something up with which I will not put.}---Sir Winston Churchill (1874--1965)
@end quotation

NodeBrain does not require a semi-colon to terminate a command at the end of a line.  The following examples are both acceptable.

@cartouche
@smallexample
> assert a=1,b=2;
> assert a=1,b=2
@end smallexample
@end cartouche

A semi-colon is required to terminate a command before a comment.

@cartouche
@smallexample
> assert a=1,b=2; # This is valid
> assert a=1,b=2  # This is not valid
@end smallexample
@end cartouche

You can not put two commands on one line.

@cartouche
@smallexample
> assert a=1,b=2; define x cell 10; # This is not valid
@end smallexample
@end cartouche

In some cases, a NodeBrain command ends with a command directed to another interpreter.  In those cases, you must follow the syntax rules of the other interpreter.  The following rule that uses a host shell command as the action is illustrated in this concept.

@cartouche
@smallexample
> define psNb on(~(m)):-@b{ps -ef | grep nb}
@end smallexample
@end cartouche

@section How do I continue a command onto the next line?

There is no support for multiple line commands.  A new-line character (@code{\n}) is always interpreted as the end of a command.

@section How can I specify multiple commands for a rule action?

If you are specifying multiple shell commands, the shell supports semi-colon (@code{;}) separated commands on a single line.

@cartouche
@smallexample
> define r1 on(a=1 and b=2):= @b{myscript1.pl; rm*.foo; myscript2.pl}
@end smallexample
@end cartouche

You may also include multiple comma-separated NodeBrain assertions.

@cartouche
@smallexample
> define r1 on(a=1 and b=2) x=5,y="abc",z=20 := @b{myscript1.pl;rm *.foo; myscript2.pl}
@end smallexample
@end cartouche

If you need to specify multiple NodeBrain commands, they cannot be specified directly in the action of a rule.  But let's look at some alternatives.

If order is important, and you want to specify several commands, place the commands in a separate source file, and use the @code{source} command as the rule action.

@cartouche
@smallexample
> define r1 on(a=1 and b=2):source r1Action.nb
@end smallexample
@end cartouche
You may also use a @code{-:} or @code{=:} (servant) command and have a servant script present multiple commands to the interpreter.

@cartouche
@smallexample
> define r1 on(a=1 and b=2):-:r1Action.pl
@end smallexample
@end cartouche
If the order of the commands is not important and the number is relatively small, you can use multiple rules with the same condition. To avoid typing the condition multiple times, specify the name of the first rule as the second rule's condition.

@cartouche
@smallexample
> define r1 on(a=1 and b=2):-myscript1.pl
> define r2 on(r1): sally. alert x=5;
> define r3 on(r2): source r3Action.nb
@end smallexample
@end cartouche

Under the current implementation, you should not expect these rules to fire in any particular order.

@section How do I include quotes within a string?

Including quotes within a string is not allowed.  Because NodeBrain is not a general purpose or report writing language, I have not yet found a reason to support quotes within a string.  When generating cell formulas manually or with a program, simply avoid generating values containing quotes.

@section Is there an escape sequence for including special characters in strings?

No, and I like it that way.  Special characters aren't necessary in NodeBrain strings.  In commands sent to the host shell and messages sent to servants or node modules, NodeBrain does not interfere with the use of any escape sequences supported by the  target interpreter. NodeBrain is oblivious to it, and this is actually why there is no interference. If a string value assigned to a NodeBrain term is ultimately destined to another interpreter (shell or node module), then you are free to include an escape sequence (except an escaped double quote). Again, NodeBrain is oblivious to it.

@node Tree
@chapter Tree Node
@cindex node, tree
@cindex tree node
@include module/tree/doc/nb_tree_tutorial.texi

@node Cache
@chapter Cache Node
@cindex cache node
@cindex node, cache
@include module/cache/doc/nb_cache_tutorial.texi

@node Baseline
@chapter Baseline Node
@cindex baseline node
@cindex node, basline
@include module/baseline/doc/nb_baseline_tutorial.texi

@node Servant
@chapter Servant Node
@cindex servant node
@cindex node, servant
@include module/servant/doc/nb_servant_tutorial.texi

@node Translator
@chapter Translator Node
@cindex translator node
@cindex node, translator
@include module/translator/doc/nb_translator_tutorial.texi

@node Audit
@chapter Audit Node
@cindex audit node
@cindex node, audit
@include module/audit/doc/nb_audit_tutorial.texi

@node Syslog
@chapter Syslog Node
@cindex syslog node
@cindex node, syslog
@include module/syslog/doc/nb_syslog_tutorial.texi

@node Snmptrap
@chapter Snmptrap Node
@cindex snmptrap node
@cindex node, snmptrap
@include module/snmptrap/doc/nb_snmptrap_tutorial.texi

@node Pipe
@chapter Pipe Node
@cindex pipe node
@cindex node, pipe
@include module/pipe/doc/nb_pipe_tutorial.texi

@node Peer
@chapter Peer Node
@cindex peer node
@cindex node, peer
@include module/peer/doc/nb_peer_tutorial.texi

@node Webster
@chapter Webster Node
@cindex webster node
@cindex node, webster
@include module/webster/doc/nb_webster_tutorial.texi

@ifnottex
@node Licenses
@unnumbered Licenses

NodeBrain is free software; you can modify and/or redistribute it, including this document, under the
terms of either the MIT License (Expat) or the NodeBrain License.

@sp 1
@include licenses.texi
@end ifnottex

@node Index
@unnumbered Index
@printindex cp

@bye
