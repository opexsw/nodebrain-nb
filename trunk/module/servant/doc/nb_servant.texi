@section Servant Module
@cindex servant module

\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nb_servant.info
@include version.texi
@settitle Servant Module
@c %**end of header

@finalout
@paragraphindent none
@setchapternewpage odd

@copying
Servant Module@*
August 2011@*
The Boeing Company, P.O. Box 3707, Seattle, WA 98124, USA

@sp 2
@b{Release 0.8}

Author: Ed Trettevik <eat@@nodebrain.org>

Copyright @copyright{} 2006, 2007, 2008, 2009, 2010, 2011 The Boeing Company

@sp 1
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section titled @i{GNU Free Documentation License} preceding the index at the end of this document.

@sp 1
NodeBrain(TM) is a trademark of The Boeing Company. All other trademarks and registered trademarks referenced in this document are the trademarks of their respective owners.

@sp 2
@b{Software License}

@multitable {------------------------------} {----------------------------------------------------}
@item Copyright @copyright{} 1998--2010 @tab The Boeing Company
@item @tab Ed Trettevik <eat@@nodebrain.org>
@end multitable

NodeBrain is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option)any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License formore details.

You should have received a copy of the GNU General PublicLicense along with this program; if not, write to Free Software Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
@end copying

@iftex
@titlepage
@c @image{./image001,32pt,32pt,,gif}

@titlefont{Servant Module}
@sp 1
@tex
\vskip4pt \hrule height 3pt width \hsize
@end tex
@sp 3
@b{Release @value{VERSION}}
@page
@vskip 0pt plus 1filll
@insertcopying

@c History Preface and Document Conventions 
@page
@b{History}

@multitable {-------------} {--------------------------------------------------------------------------------------------------------}
@item 2005-10-12 @tab
Title: @i{NodeBrain Tutorial}@*
Author: Ed Trettevik <eat@@nodebrain.org>@*
Publisher: The Boeing Company

@item 2010-12-31 @tab
Release 0.8.3
@itemize @bullet
@item Updates - still needed
@end itemize

@end multitable

@page
@b{Preface}

@sp 1
This tutorial is intended for readers seeking an introduction to NodeBrain through a series of simple examples. Other documents are available for readers looking for a more complete reference to the rule language, modules, or API (application programmatic interface).

The intent of the examples in this tutorial is to illustrate individual concepts, not to provide complete working applications or show all related options.
We avoid formal syntax descriptions, thinking you are here because you want to figure it out from examples.  

Files referenced in this tutorial are included in the tutorial directory of the NodeBrain distribution.  

See www.nodebrain.org for more information and the latest update to this document.

@sp 2
@b{Documents}
@sp 1
@quotation
@i{NodeBrain Tutorial}

@i{NodeBrain User Guide}

@i{NodeBrain Language Reference}

@i{NodeBrain Module Reference}

@i{NodeBrain API Reference}
@end quotation

@sp 2
@b{Document Conventions}
@sp 1
Sample code and input/output examples are displayed in a monospace font, indented in HTML and Info, and enclosed in a box in PDF or printed copies.
Bold text is used to bring the reader's attention to specific portions of an example.
In the following example, the first and last line are associated with the host shell and the lines in between are input or output unique to NodeBrain.
The @code{define} command is highlighted, indicating it is the focus of the example.
Lines starting with "@dots{}" are a continuation of the previous line ending with "@dots{}".
This is not part of the language, just one way of breaking up single lines to fit on a printed page.
If you copy an example, you must remove the dots and combine the lines into a single line.

@example
$ nb
> @b{define myFirstRule on(a=1 and b=2) mood="happy";}
> assert mood="sad";
> show mood
mood = "sad"
> assert a=1,b=2,c=3,d="This is an example of a long single line that", @dots{}
@dots{} e="we depict on multiple lines to fit on the documnet page";
2008/06/05 12:09:08 NB000I Rule myFirstRule fired(mood="happy")
> show mood
mood = "happy"
> quit
$
@end example

@end titlepage

@end iftex

@c ----------------------------------------------------------
@c Not printed document

@ifnottex
@node Top
@top NodeBrain Tutorial @value{VERSION}

This tutorial is for NodeBrain (version @value{VERSION}, @value{UPDATED}), an open source agent for state and event monitoring.

Copyright @copyright{} 2006, 2007, 2008, 2009, 2010, 2011 The Boeing Company

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section titled @i{GNU Free Documentation License} preceding the index at the end of this document.
@end quotation

@ifnotplaintext
@b{Rule Engine Tutorials}
@end ifnotplaintext
@menu
@end menu

@ifnotplaintext
@b{Node Module Tutorials}
@end ifnotplaintext
@menu
@end menu

@ifnotplaintext
@b{References}
@end ifnotplaintext
@menu
* Index::
@end menu
@end ifnottex

@c Set page footings
@oddfooting @thistitle @| @| @thispage
@evenfooting @thispage @| @| @thistitle

@c Contents
@oddheading @| @| 
@evenheading @| @|
@contents

@c Set page headings for document
@oddheading @thischapter @| @| @value{UPDATED-MONTH}
@evenheading @value{UPDATED-MONTH} @| @| @thischapter


@section Servant Module
@cindex Servant Module

In NodeBrain terminology, a servant is a program that communicates with NodeBrain via @code{stdin} and @code{stdout}, or that is spawned by NodeBrain to perform a specific action. A servant may run as a child process of NodeBrain or may pipe to NodeBrain’s @code{stdin} or from NodeBrain’s @code{stdout}. This topic is covered in the @i{NodeBrain User Guide} and under the servant prefix command ("-" or "=") in the NodeBrain Language Reference.

The servant module, like the servant command, makes it easy for programmers to develop in their favorite programming languages when interfacing to NodeBrain rules. Scripting languages like Perl are convenient for creating servants. You should only consider writing new NodeBrain node modules when a problem cannot be solved as well by writing a servant.

@subsection Servant Module vs. Servant Command
@cindex Servant Module vs. Servant Command

Servants defined using the servant node module differ from those defined by the servant command ("-" or "=") in the following ways.

@enumerate

@item Rules can send messages to a servant defined by this node module on @code{stdin} in addition to accepting commands on the servant’s @code{stdout}.

@item Servants defined by this node module are not enabled (spawned) until NodeBrain enters a server mode (servant or agent). This is necessary in the case of daemons (-d) because the NodeBrain process terminates when it spawns itself as a daemon. Any processes started before entering daemon mode are orphaned and no longer able to communicate on @code{stdin} or @code{stdout}. This is also helpful for other server modes (e.g., servant) because it enables all the startup rules to be fully defined before a servant starts generating commands.

@item In the future, servants defined by this node module may be disabled, enabled, stopped, and restarted. This is possible because they have a name that can be used as a reference. The servant command ("-" and "=") only identifies a servant by process ID (PID), and although the PID is displayed and can be referenced in shell commands like @code{KILL}, the PID is not captured in a way that NodeBrain rules can reference.

@end enumerate

@subsection Servant Definition
@cindex Servant Definition

A servant is defined as a node, where the foreign text includes the full syntax of the servant command ("-" or "=").

 
@subheading Syntax
@multitable {----------------------} {--------------------------------------------------------------} 
	   
	@item @i{servantDefinition}	
	@tab ::= @b{define} @v{s} @i{term} @v{s} @b{node} [@v{s} @i{servantSpec} ] @bullet{} 	   
			   
	@item @i{servantSpec}	
	@tab ::= @b{servant} [ @b{(} @i{servantOptions} @b{(} ]  @b{:} [ @b{|} ] @i{servantCmd}	   
			   
	@item @i{servantOptions}	
	@tab ::= there are currently no options defined for this module	   
			   
	@item @i{servantCmd}	
	@tab ::= see "-" and "=" command in the @i{NodeBrain Language Reference}	   
	@end multitable		 

@subsection Sending Servant Messages
@cindex Sending Servant Messages

Once NodeBrain is running in a server mode (e.g., agent/daemon/service or servant), you may pass messages to a servant using a node command. Suppose you define a Perl script named @code{servant.pl} as a servant named @i{servant}.

@example

	define servant node servant:|=:./servant.pl
@end example


Once in server mode, you can pass a message to @code{servant.pl} on @code{stdin} as follows.

@example

	servant:@i{message}
@end example

This is how you pass messages to any node. In this case, the servant node module simply forwards all messages to the specified servant program on @code{stdin}.

@subsection Receiving Servant Messages
@cindex Receiving Servant Messages
Messages received from a servant are NodeBrain commands and are automatically interpreted in the servant’s context. This is no different than receiving messages from a servant command ("-:" or "=:"). In both cases, the messages are interpreted as NodeBrain commands within the context in which they are specified.

Let’s look at a trivial example. Suppose the @code{servant.pl} looks like this.

@example
#!/usr/bin/perl
use FileHandle;
STDOUT->autoflush(1);  # flush stdout as soon as we write to it
while(<>)@{
   if(/^on$/)@{print("assert status=1;\n");@}
   elsif(/^off$/)@{print(“assert status=0;\n”);@}
   else@{print("assert ?status;\n");@}
   @}  
@end example


Now let’s define the following NodeBrain daemon script and call it @code{servant.nb}.

@example

#!/usr/local/bin/nb –d
set log="servant.log";
-cp /dev/null servant.txt
define taylor   node servant:=:tail –f servant.txt
define servant node servant:|=:./servant.pl
servant. define hello on(.status=1):-echo "hi"
@end example



The following commands will cause the daemon to echo "hi" to the log file twice.

@example
$ ./servant.nb
$ echo "servant:on" >> servant.txt
$ echo "servant:off" >> servant.txt
$ echo "servant:on" >> servant.txt
@end example

The servant named "taylor" uses the @code{tail} command to input anything you write to @code{servant.txt}. You emptied it out in the line before the servant definition to prevent @code{tail} from giving you old commands from a previous session. When you echo the NodeBrain command (e.g., "servant:on") to @code{servant.txt}, @code{tail} sends them to the servant node module, which passes them on to the NodeBrain interpreter. These commands happen to address the second servant, the one executing the @code{servant.pl} script. The values of "on," "off," and "on" are sent to this script on @code{stdin}. The @code{servant.pl} script simply translates these messages into NodeBrain commands that set a value for the "status" term. When status is set to 1, the "hello" rule fires.

Obviously the @code{servant.pl} script in this example isn’t giving you any information you don’t already know, so it is of little or no value. You could have just echoed "servant.status=1;" to @code{servant.txt} in place of "servant:on." But the goal here is just to illustrate the servant interface. It should not be difficult to imagine more realistic situations where you send messages to a servant instructing it when to provide information or what information to provide. For example, the servant could check to see whether a process is running or how much space is available in a file system. Servants just need to know how to perform a function or get some information. The NodeBrain rules decide how to respond to the information provided and when specific actions are appropriate.

@subsection Running Multiple NodeBrain Processes
@cindex Running Multiple NodeBrain Processes

The servant module can run NodeBrain (nb) in a new process the same way it runs servant programs and scripts. The servant module’s support for two-way message communication between processes enables a NodeBrain application to be divided into multiple processes. When you define a servant that executes NodeBrain, messages sent to @code{stdin} and received from @code{stdout} are all NodeBrain commands. This allows the processes to share information and make decisions or take actions as a service to each other.

When NodeBrain is run as a servant to another NodeBrain process, use the –s (servant) option if you want the child to run as a server. Use the "=" option instead if you want the child to operate in batch mode.  

The @i{NodeBrain Language Reference} provides a description of NodeBrain options and the full syntax of the servant command ("-" or "="), which is critical to understanding the syntax used by the servant module. 


@node Index 
@unnumbered Index 
@printindex cp 
@bye 

