\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nb_audit.info
@include version.texi
@settitle Audit Module
@c %**end of header

@finalout
@paragraphindent none
@setchapternewpage odd

@copying
Audit Module@*
June 2012@*
The Boeing Company, P.O. Box 3707, Seattle, WA 98124, USA

@sp 2
@b{Version @value{VERSION}}

Author: Ed Trettevik <eat@@nodebrain.org>

Copyright @copyright{} 2012 The Boeing Company

@sp 1
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is included in the section titled @i{GNU Free Documentation License} preceding the index at the end of this document.

@sp 1
NodeBrain(TM) is a trademark of The Boeing Company.   All other trademarks and registered trademarks referenced in this document are the trademarks of their respective owners.

@sp 2
@b{Software License}

@multitable {------------------------------} {----------------------------------------------------}
@item Copyright @copyright{} 1998-2012 @tab The Boeing Company
@item @tab Ed Trettevik <eat@@nodebrain.org>
@end multitable

The Audit NodeBrain Module is free software; you can redistribute it and/or  modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option)any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License formore details.

You should have received a copy of the GNU General PublicLicense along with this program; if not, write to Free Software Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
@end copying

@iftex
@titlepage
@c @image{./image001,32pt,32pt,,gif}

@titlefont{Audit NodeBrain Module}
@sp 1
@tex
\vskip4pt \hrule height 3pt width \hsize
@end tex
@sp 3
@b{Version @value{VERSION}}
@page
@vskip 0pt plus 1filll
@insertcopying

@c History Preface and Document Conventions 
@page
@b{History}

@multitable {-------------} {--------------------------------------------------------------------------------------------------------}
@item 2012-06-04 @tab
Title: @i{Audit NodeBrain Module}@*  
Author: Ed  Trettevik <eat@@nodebrain.org>@*
Publisher: The Boeing Company

@item 2012-06-04 @tab
Release 0.8.10
@itemize @bullet
@item This is a first edition.
@end itemize

@end multitable

@page
@b{Preface}

@sp 1
This manual is intended for users of the Audit NodeBrain Module, a plug-in for monitoring system and application log files.
The reader is expected to be familiar with the basic concepts of NodeBrain.  See www.nodebrain.org for general information
on NodeBrain.
@sp 1
The function this module performs was included in the original prototype of NodeBrain as a "log listener", but the code was
later removed from the intepreter and repackaged as the Audit module.  

@sp 2
@b{Documents}
@sp 1
@quotation
@i{NodeBrain Tutorial}

@i{NodeBrain User Guide}

@i{NodeBrain Language Reference}

@i{NodeBrain Module Reference}

@i{NodeBrain API Reference}
@end quotation

@sp 2
@b{Document Conventions}
@sp 1
Sample code and input/output examples are displayed in a monospace font, indented in HTML and Info, and enclosed
in a box in PDF or printed copies.
Bold text is used to bring the reader's attention to specific portions of an example.
In the following example, the first and last line are associated with the host shell and the lines in between are input or output unique to NodeBrain.
The @code{define} command is highlighted, indicating it is the focus of the example.
Lines starting with "@dots{}" are a continuation of the previous line ending with "@dots{}".
This is not part of the language, just one way of breaking up single lines to fit on a printed page.
If you copy an example, you must remove the dots and combine the lines into a single line.

@example
$ nb
> @b{define myFirstRule on(a=1 and b=2) mood="happy";}
> assert mood="sad";
> show mood
mood = "sad"
> assert a=1,b=2,c=3,d="This is an example of a long single line that", @dots{}
@dots{} e="we depict on multiple lines to fit on the documnet page";
2008/06/05 12:09:08 NB000I Rule myFirstRule fired(mood="happy")
> show mood
mood = "happy"
> quit
$
@end example

@end titlepage

@end iftex

@c ----------------------------------------------------------
@c Not printed document

@ifnottex
@node Top
@top Audit NodeBrain Module @value{VERSION}

This manual is for the Audit NodeBrain Module (version @value{VERSION}, @value{UPDATED}) used to monitor system and application log files.
@*@*
Copyright @copyright{} 2012 The Boeing Company
@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is included in the section titled @i{GNU Free Documentation License} at the end of this document.
@end quotation
@ifnotplaintext
@b{Short Table Of Contents}
@menu
* Concepts:: Foundation
* Tutorial:: Introduction by Example
* Commands:: Syntax and Semantics
* Triggers:: Conditions and Response
@end menu
@menu
* GNU Free Documentation License::
* Index::
@end menu
@end ifnotplaintext
@end ifnottex

@c Set page footings
@oddfooting @thistitle @| @| @thispage
@evenfooting @thispage @| @| @thistitle

@c Contents
@oddheading @| @| 
@evenheading @| @|
@contents

@c Set page headings for document
@oddheading @thischapter @| @| @value{UPDATED-MONTH}
@evenheading @value{UPDATED-MONTH} @| @| @thischapter

@node Concepts
@chapter Concepts
@cindex Concepts

The Audit module implements nodes that monitor lines of text written to system and application log files.
This enables event monitoring in situations where an application provides no other mechanism for communicating events to a monitoring system.  

@section Translators
NodeBrain translators are used to convert a sequence of text strings into a sequence of NodeBrain commands.
Regular expressions are used to find specific patterns of text and matching strings are combined with new text to construct NodeBrain commands.
An Audit node follows the end of a growing text file and passes each new line into a configured translator. 
See the @i{NodeBrain Language Reference} for information on coding translators.

@section Log File Rotation
@cindex log file rotation
An enabled Audit node opens the log file on a scheduled frequency and reads from the last end-of-file to the new end-of-file
and closes the file.  Before reading, the new size of the file is checked.  If the file is smaller than the last time, the Audit node starts over and reads from the beginning of the file.

@section Missed Messages
@cindex missed messages
New lines in a log file are only monitored by an Audit node while the node is enabled (listening).
If the node is disabled or the NodeBrain agent is stopped, new lines are ignored and never processed.
When the agent is restarted and/or the node is enabled, subsequent new lines will be monitored.
An option to maintain a separate cursor file providing the offset of the next line to monitor, with a check for log rotation based on inode will be included in a future release.

It is also possible for a log file to rotate and fill fast enough to become larger than the size it was the last time the Audit node read to end-of-file.  This is unlikely, but possible if the log file in uneven bursts and the Audit node's polling frequency is too slow relative to the rotation frequency.

If your application can not tolerate missed messages, however seldom, you should select a different option than the Audit node for getting messages into NodeBrain.  It is sufficient for many situations, but not all.

@node Tutorial
@chapter Tutorial
@cindex tutorial

@quotation
@i{If Edison had a needle to find in a haystack, he would proceed at once with the diligence of the bee to examine straw after straw until he found the object of his search.... I was a sorry witness of such doings, knowing that a little theory and calculation would have saved him ninety per cent of his labor.}
---Nikola Tesla (1857--1943), @i{New York Times}, October 19, 1931
@end quotation

Effective review of system and application logs can be like trying to find a needle in a haystack.  It requires at least one Edison and one Tesla working as a team.  The Audit node module works like Edison when reviewing logs so you can work like Tesla.

An Audit node is similar to the Translator node covered in an earlier tutorial, but differs in the way lines of text are input for translation.  An Audit node starts at the end of a log file and periodically checks for new lines to translate.  When a log file rolls, the Audit node starts at the beginning of the new log file.

The content of system and application log files can vary significantly depending on the mix of applications on a system and how they are configured.  A good strategy is to treat log entries as worthy of investigation by default.  Duplicate suppression and other flood protection techniques are helpful when using this strategy.  As new log entries are reported and investigated, you can decide if they should be suppressed or handled in a special way.

@section Agent Rules

The @code{syslog.nb} file below provides an agent with an Audit node to monitor a log file called @code{syslog}.
It specifies a translator named @code{syslog.nbx} and a polling interval of 10 seconds.
(A longer interval is recommended for real applications.)
It also includes a deduplication cache.
@example
#!/usr/local/bin/nb -d
# File: tutorial/Audit/syslog.nb
set log="syslog.log",out=".";
define syslog node cache(~(h(8))):(~(1h):route,appl,group,node,object,severity,text(1));
syslog. define alarm if(text._hitState):$ -|mail.form @dots{}
@dots{} source=tutorial route="$@{route@}" appl="$@{appl@}" group="$@{group@}" @dots{}
@dots{} node="$@{node@}" severity="$@{severity@}" text="$@{text@}" >> mail.log
@b{syslog. define audit node audit("syslog","syslog.nbx",~(10s));}
@end example

@section Sample Log

Here's a small sample of a log file in the format to use for this tutorial.
A copy of this file is stored as @code{tutorial/Audit/syslog.sample}.

@example
Feb  1 19:00:04 smk001 sshd[3972]: Accepted publickey for myuser @dots{}
@dots{} from ::ffff:192.168.1.100 port 53403 ssh2
Feb  1 19:00:06 smk001 sshd[3980]: Accepted publickey for myuser @dots{}
@dots{} from ::ffff:192.168.1.101 port 53410 ssh2
Feb  1 19:00:16 smk001 kernel: z90crypt: probe_crypto_domain -> @dots{}
@dots{} Unable to find crypto domain: No devices found
Feb  1 19:00:46 smk001 kernel: z90crypt: probe_crypto_domain -> @dots{}
@dots{} Unable to find crypto domain: No devices found
Feb  1 19:01:16 smk001 kernel: z90crypt: probe_crypto_domain -> @dots{}
@dots{} Unable to find crypto domain: No devices found
Feb  1 19:01:19 smk001 su: (to root) myuser on /dev/pts/1
@end example

@section Translation Rules

Here's a small translator called @code{syslog.nbx} designed for the log format above.

@example
# File: tutorial/Audit/syslog.nbx
([a-zA-Z]+ +\d+ \d\d:\d\d:\d\d [^ ]+ )@{
  (^-- MARK --)
  (^\/USR\/SBIN\/CRON\[\d+\]: [^ ]+ CMD)
  (^last message repeated \d+ times)
  (^kernel: )@{
    (^z90crypt: probe_crypto_domain -> Unable to find crypto domain: No devices found)
    (^end_request: I\/O error)
    (^dasd_erp.*:Perform logging requested)
    (^dasd:.*:ERP successful)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 kernel: $[=]");
    @}
  (^su: )@{
    (^pam_unix2: session (started|finished) for user (nobody|root|wwwadm|cyrus), service su)
    (^\(to (nobody|cyrus)\) root on none)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 su: $[=]");
    @}
  (^sshd\[\d+\]: )@{
    (^Accepted password for myuser from ::ffff:.* port \d+ ssh2)
    (^Accepted publickey for myuser from ::ffff:.* port \d+ ssh2)
    (^error: Could not get shadow information for NOUSER)
    (^(?'preport'.*port) \d+ )@{
      :syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
      @dots{} "SYS0000 sshd[*]: $[preport]port * $[=]");
      @}
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 sshd[*]: $[=]");
    @}
  @}
():syslog. assert ("syslog","syslog","OS","","","critical","SYS0000 $[-]");
@end example

@page
@section Start the Agent

Before starting the agent, you must touch  @code{syslog} to make sure it exists.

@example
$ ./syslog.nb
2009/02/01 19:56:57 NB000I Argument [1] -d
2009/02/01 19:56:57 NB000I Argument [2] ./syslog.nb
> #!/usr/local/bin/nb -d
> # File: tutorial/Audit/syslog.nb
> set log="syslog.log",out=".";
2009/02/01 19:56:57 NB000I NodeBrain nb will log to syslog.log
> define syslog node cache(~(h(8))):(~(1h):route,appl,group,node,object,severity,text(1));
> syslog. define alarm if(text._hitState):$ -|mail.form @dots{}
@dots{} source=tutorial route="$@{route@}" appl="$@{appl@}" group="$@{group@}" @dots{}
@dots{} node="$@{node@}" severity="$@{severity@}" text="$@{text@}" >> mail.log
> syslog. define audit node audit("syslog","syslog.nbx",~(10s));
2009/02/01 19:56:57 NB000I Loading translator "syslog.nbx"
---------- --------
# File: tutorial/Audit/syslog.nbx
([a-zA-Z]+ +\d+ \d\d:\d\d:\d\d [^ ]+ )@{
  (^-- MARK --)
  (^\/USR\/SBIN\/CRON\[\d+\]: [^ ]+ CMD)
  (^last message repeated \d+ times)
  (^kernel: )@{
    (^z90crypt: probe_crypto_domain -> Unable to find crypto domain: No devices found)
    (^end_request: I\/O error)
    (^dasd_erp.*:Perform logging requested)
    (^dasd:.*:ERP successful)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 kernel: $[=]");
    @}
  (^su: )@{
    (^pam_unix2: session (started|finished) for user (nobody|root|wwwadm|cyrus), service su)
    (^\(to (nobody|cyrus)\) root on none)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 su: $[=]");
    @}
  (^sshd\[\d+\]: )@{
    (^Accepted password for myuser from ::ffff:.* port \d+ ssh2)
    (^Accepted publickey for myuser from ::ffff:.* port \d+ ssh2)
    (^error: Could not get shadow information for NOUSER)
    (^(?'preport'.*port) \d+ )@{
      :syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
      @dots{} "SYS0000 sshd[*]: $[preport]port * $[=]");
      @}
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 sshd[*]: $[=]");
    @}
  @}
():syslog. assert ("syslog","syslog","OS","","","critical","SYS0000 $[-]");
---------- --------
2009/02/01 19:56:57 NB000I Translator "syslog.nbx" loaded successfully.
2009/02/01 19:56:57 NB000I Source file "./syslog.nb" included. size=425
2009/02/01 19:56:57 NB000I NodeBrain nb[6749,3352] daemonizing
$
@end example

@section Grow the Log

Use a shell script to append the sample log file @code{syslog.sample} to the monitored @code{syslog} file three times.

@example
# File: tutorial/Audit/syslog.sh
cat syslog.sample >> syslog
cat syslog.sample >> syslog
cat syslog.sample >> syslog
@end example

@section Review the Agent Log

After executing the @code{syslog.sh} script above, your @code{syslog.log} file should look like this.

@example
2009/02/01 19:59:35 NB000I Agent log is syslog.log
2009/02/01 19:59:35 NM000I audit audit: Enabled audit of syslog using syslog.nbx
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
2009/02/01 20:00:05 NB000I Rule syslog.alarm fired
: syslog. -|mail.form source=tutorial route="syslog" appl="syslog" group="OS" @dots{}
@dots{} node="" severity="normal" text="SYS0000 su: (to root) myuser on /dev/pts/1" >> mail.log
[6957] Started: -|mail.form source=tutorial route="syslog" appl="syslog" group="OS" @dots{}
@dots{} node="" severity="normal" @dots{}
@dots{} text="SYS0000 su: (to root) myuser on /dev/pts/1" >> mail.log
[6957] Exit(0)
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
@end example

Notice that the translator only asserted the @code{su} log entries to the @code{syslog} cache.
This is because the translator was coded to ignore the other entries in the sample log file.
Notice also that the agent only generated an alarm once.
This is because the @code{syslog} cache node was coded to ignore duplicates until 8:00 AM unless they are separated by 1 hour.

Although you used a system log for this tutorial, you can code a translator for application logs as well.
In fact, the more unique your application log, the more likely you will need to construct your own custom log monitor.

If you started the agent for this tutorial, you should kill it now.


@node Commands
@chapter Commands
@cindex commands

This section describes define commands used with an Audit node.
 
@section Define
@cindex define command

The @command{define} command is used to create an Audit node.
 
@subheading Syntax
@multitable {---------------------} {---------------------------------------------------------------}
	   
	@item @i{auditDefineCmd}	
	@tab ::= @b{define} @v{s} @i{term} @v{s} @b{node} [@v{s}@i{audiDef} ] @bullet{} 	   
			   
	@item @i{auditDef}	
	@tab ::= @b{audit(} "@i{filename} " , " @i{translatorName} " , @i{schedule} @b{)};	   
			   
	@item @i{filename}	
	@tab ::= name of file to audit	   
			   
	@item @i{translatorName}	
	@tab ::= name of translator file (*.nbx)	   
			   
	@item @i{schedule}	
	@tab ::= @i{cellExpression}    	   

        @end multitable		 

@*
The @i{filename} and @i{translatorName} arguments may be any cell expression that resolves to a string value containing a filename. The value at definition time is used. An audit node will not response to or recognize changes to the value of expressions for these parameters.

The @i{translatorName} by convention has a ".nbx" suffix. See "Translators" under the @command{DEFINE} command in the @i{NodeBrain Language Reference} for instructions on coding translator files.

The schedule parameter may be any cell expression. New lines in the audit file are translated each time the schedule parameter transitions to TRUE. Normally a time condition is used to check the audit file for new lines on a periodic basis (e.g., every 10 seconds) as show in the following example.

@example
	define msgAudit node audit("/var/adm/messages","messages.nbx",~(10s));
@end example

@section Assert
@cindex assert command

Assertions are not supported by this module.

@section Disable
@cindex disable command

The @command{disable} commands may be used to stop the node from listening for syslog messages on the specified port.

@example
disable @i{node}
@end example

@section Enable
@cindex enable command

The @command{enable} command may be used to start listening for syslog messages on the specified port.

@example
enable @i{node}
@end example

An Audit node is automatically enabled when an agent goes into background mode (daemonizes).  So the enable command is
only required if you want to enable it when running in a different mode, or to re-enable the node after it has been
disabled.

@section Node Commands
@cindex node commands


A trace mode can be toggled on or off to assist in debugging translator rules. When trace is on, lines from the file are displayed when processed.

@example
	@i{node}:@b{trace}
	@i{node}:@b{notrace}
@end example

@section Module Commands

The Audit module currently implements no module commands.

@node Triggers
@chapter Triggers
@cindex triggers

All the triggers of an audit node are implemented by the specified translator.
Because all commands generated by an audit node's translator are interpreted within the audit node's context, it is necessary to design the rules to work in concert with the translator. If the translator generates @command{alert} commands, you will want @command{if} rules. If the translator generates @command{assert} commands, you will want @command{on} rules. It is not actually necessary to define rules within the audit node context. As an alternative, the translator may use a context prefix to direct commands to a different context. One common possibility is to define multiple audit nodes as children of a common node and have each audit node generate commands to the parent node. It is also common to use translators that generate commands to a variety of other nodes. 


@node GNU Free Documentation License
@unnumbered GNU Free Documentation License
@include fdl.texi

@node Index
@unnumbered Index 
@printindex cp 
@bye 

